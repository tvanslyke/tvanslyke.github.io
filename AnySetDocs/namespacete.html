<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AnySet Documentation: te Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AnySet Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">te Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Primary classes and utility functions for <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyHash.html">AnyHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic hash function object.  <a href="structte_1_1AnyHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnySet.html">AnySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> is an associative container that contains a set of unique objects of any constructible type. Search, insertion, and removal have average constant-time complexity. Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.  <a href="structte_1_1AnySet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1AnyValue.html">AnyValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1CompressedPair.html">CompressedPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1ConstValueHolder.html">ConstValueHolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1ConstValueHolder_3_01Value_00_01Tag_00_01false_01_4.html">ConstValueHolder&lt; Value, Tag, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1ConstValueHolder_3_01Value_00_01Tag_00_01true_01_4.html">ConstValueHolder&lt; Value, Tag, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1CopyConstructionError.html">CopyConstructionError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of <a class="el" href="structte_1_1NoCopyConstructorError.html" title="Exception thrown when attempting to make copies of an AnyValue instance that contains an instance of ...">NoCopyConstructorError</a>. Thrown when attempting to make copies of an <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance that contains a non-copy-constructible type.  <a href="structte_1_1CopyConstructionError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1Hash.html">Hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that implements a hash function for instances of type T. Inherits from std::hash&lt;T&gt; unless otherwise specialized by the user to not do so.  <a href="structte_1_1Hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1Hash_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">Hash&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="structte_1_1Hash.html" title="Function object that implements a hash function for instances of type T. Inherits from std::hash&lt;T&gt; u...">te::Hash</a> for std::array.  <a href="structte_1_1Hash_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1Hash_3_01std_1_1complex_3_01T_01_4_01_4.html">Hash&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="structte_1_1Hash.html" title="Function object that implements a hash function for instances of type T. Inherits from std::hash&lt;T&gt; u...">te::Hash</a> for std::complex.  <a href="structte_1_1Hash_3_01std_1_1complex_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1Hash_3_01std_1_1pair_3_01T_00_01U_01_4_01_4.html">Hash&lt; std::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="structte_1_1Hash.html" title="Function object that implements a hash function for instances of type T. Inherits from std::hash&lt;T&gt; u...">te::Hash</a> for std::pair.  <a href="structte_1_1Hash_3_01std_1_1pair_3_01T_00_01U_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1Hash_3_01std_1_1tuple_3_01T_8_8_8_01_4_01_4.html">Hash&lt; std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="structte_1_1Hash.html" title="Function object that implements a hash function for instances of type T. Inherits from std::hash&lt;T&gt; u...">te::Hash</a> for std::tuple.  <a href="structte_1_1Hash_3_01std_1_1tuple_3_01T_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1Hash_3_01void_01_4.html">Hash&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that implements a hash function for instances of type T.  <a href="structte_1_1Hash_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1NoCopyConstructorError.html">NoCopyConstructorError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when attempting to make copies of an <a class="el" href="structte_1_1AnyValue.html">AnyValue</a> instance that contains an instance of non-copyable type T.  <a href="structte_1_1NoCopyConstructorError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1ValueHolder.html">ValueHolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1ValueHolder_3_01Value_00_01Tag_00_01false_01_4.html">ValueHolder&lt; Value, Tag, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structte_1_1ValueHolder_3_01Value_00_01Tag_00_01true_01_4.html">ValueHolder&lt; Value, Tag, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aada48d16176299bdced222327e34e467"><td class="memTemplParams" colspan="2"><a id="aada48d16176299bdced222327e34e467"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:aada48d16176299bdced222327e34e467"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;set)</td></tr>
<tr class="separator:aada48d16176299bdced222327e34e467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f984e75977e4d8c988eff27488877"><td class="memTemplParams" colspan="2"><a id="a731f984e75977e4d8c988eff27488877"></a>
template&lt;class T , class H , class C &gt; </td></tr>
<tr class="memitem:a731f984e75977e4d8c988eff27488877"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_as</b> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;self)</td></tr>
<tr class="separator:a731f984e75977e4d8c988eff27488877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56ac2a79619580fb5fa4ddfdb46e29f"><td class="memTemplParams" colspan="2"><a id="af56ac2a79619580fb5fa4ddfdb46e29f"></a>
template&lt;class T , class H , class C &gt; </td></tr>
<tr class="memitem:af56ac2a79619580fb5fa4ddfdb46e29f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as</b> (const <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &amp;self)</td></tr>
<tr class="separator:af56ac2a79619580fb5fa4ddfdb46e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c98d7bb9bfa86a2744292ca51a3777"><td class="memTemplParams" colspan="2"><a id="a01c98d7bb9bfa86a2744292ca51a3777"></a>
template&lt;class T , class H , class C , class ... Args&gt; </td></tr>
<tr class="memitem:a01c98d7bb9bfa86a2744292ca51a3777"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_any_value</b> (std::size_t hash_value, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a01c98d7bb9bfa86a2744292ca51a3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a41578cc0cee7503a236de642e1429"><td class="memTemplParams" colspan="2"><a id="a80a41578cc0cee7503a236de642e1429"></a>
template&lt;class T , class H , class C , class ... Args&gt; </td></tr>
<tr class="memitem:a80a41578cc0cee7503a236de642e1429"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structte_1_1AnyValue.html">AnyValue</a>&lt; H, C &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_any_value</b> (H hasher, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a80a41578cc0cee7503a236de642e1429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af55cdba1dea854f35b0bf5ef4cab59"><td class="memTemplParams" colspan="2"><a id="a3af55cdba1dea854f35b0bf5ef4cab59"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3af55cdba1dea854f35b0bf5ef4cab59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1CompressedPair.html">CompressedPair</a>&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_compressed_pair</b> (T &amp;&amp;left, U &amp;&amp;right)</td></tr>
<tr class="separator:a3af55cdba1dea854f35b0bf5ef4cab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa37393accbaf58639eca3c6242f12b"><td class="memTemplParams" colspan="2"><a id="abfa37393accbaf58639eca3c6242f12b"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:abfa37393accbaf58639eca3c6242f12b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="structte_1_1CompressedPair.html">CompressedPair</a>&lt; T, U &gt; &amp;left, <a class="el" href="structte_1_1CompressedPair.html">CompressedPair</a>&lt; T, U &gt; &amp;right) noexcept(noexcept(left.swap(right)))</td></tr>
<tr class="separator:abfa37393accbaf58639eca3c6242f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Operation Free-Functions</div></td></tr>
<tr class="memitem:a96af90d19e85c0a21e7016b9da6647e2"><td class="memTemplParams" colspan="2">template&lt;class T , class ... U&gt; </td></tr>
<tr class="memitem:a96af90d19e85c0a21e7016b9da6647e2"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a96af90d19e85c0a21e7016b9da6647e2">union_of</a> (T &amp;&amp;first, U &amp;&amp;... args)</td></tr>
<tr class="memdesc:a96af90d19e85c0a21e7016b9da6647e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the union of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.  <a href="#a96af90d19e85c0a21e7016b9da6647e2">More...</a><br /></td></tr>
<tr class="separator:a96af90d19e85c0a21e7016b9da6647e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f7b687336b2d915149f96ab2f46d43"><td class="memTemplParams" colspan="2">template&lt;class T , class ... U&gt; </td></tr>
<tr class="memitem:a76f7b687336b2d915149f96ab2f46d43"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a76f7b687336b2d915149f96ab2f46d43">intersection_of</a> (T &amp;&amp;first, U &amp;&amp;... args)</td></tr>
<tr class="memdesc:a76f7b687336b2d915149f96ab2f46d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.  <a href="#a76f7b687336b2d915149f96ab2f46d43">More...</a><br /></td></tr>
<tr class="separator:a76f7b687336b2d915149f96ab2f46d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a1eea7d24abfebac401d200d4aa33d"><td class="memTemplParams" colspan="2">template&lt;class T , class ... U&gt; </td></tr>
<tr class="memitem:a64a1eea7d24abfebac401d200d4aa33d"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a64a1eea7d24abfebac401d200d4aa33d">symmetric_difference_of</a> (T &amp;&amp;first, U &amp;&amp;... args)</td></tr>
<tr class="memdesc:a64a1eea7d24abfebac401d200d4aa33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the symmetric difference of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.  <a href="#a64a1eea7d24abfebac401d200d4aa33d">More...</a><br /></td></tr>
<tr class="separator:a64a1eea7d24abfebac401d200d4aa33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2492f1240f4a5089141900d2820dcc3"><td class="memTemplParams" colspan="2">template&lt;class T , class ... U&gt; </td></tr>
<tr class="memitem:ab2492f1240f4a5089141900d2820dcc3"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#ab2492f1240f4a5089141900d2820dcc3">difference_of</a> (T &amp;&amp;left, const U &amp;... right)</td></tr>
<tr class="memdesc:ab2492f1240f4a5089141900d2820dcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (asymmetric) difference of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances.  <a href="#ab2492f1240f4a5089141900d2820dcc3">More...</a><br /></td></tr>
<tr class="separator:ab2492f1240f4a5089141900d2820dcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5d37b813da99bc5717fef4f6c6b07a"><td class="memTemplParams" colspan="2">template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a8c5d37b813da99bc5717fef4f6c6b07a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a8c5d37b813da99bc5717fef4f6c6b07a">is_subset_of</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;sub, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;super)</td></tr>
<tr class="memdesc:a8c5d37b813da99bc5717fef4f6c6b07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether <code>sub</code> is a subset of <code>super</code>.  <a href="#a8c5d37b813da99bc5717fef4f6c6b07a">More...</a><br /></td></tr>
<tr class="separator:a8c5d37b813da99bc5717fef4f6c6b07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af803743f099b520c33c716952839df1d"><td class="memTemplParams" colspan="2">template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:af803743f099b520c33c716952839df1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#af803743f099b520c33c716952839df1d">is_superset_of</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;super, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;sub)</td></tr>
<tr class="memdesc:af803743f099b520c33c716952839df1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether <code>super</code> is a superset of <code>sub</code>.  <a href="#af803743f099b520c33c716952839df1d">More...</a><br /></td></tr>
<tr class="separator:af803743f099b520c33c716952839df1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Union Operators</div></td></tr>
<tr class="memitem:a5a7baaa896135caff7afcb7417c19098"><td class="memTemplParams" colspan="2"><a id="a5a7baaa896135caff7afcb7417c19098"></a>
template&lt;class T , class U , class  = std::enable_if_t&lt;		detail::is_any_set_v&lt;std::decay_t&lt;T&gt;&gt;		and std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;	&gt;&gt; </td></tr>
<tr class="memitem:a5a7baaa896135caff7afcb7417c19098"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a5a7baaa896135caff7afcb7417c19098">operator+</a> (T &amp;&amp;left, U &amp;&amp;right)</td></tr>
<tr class="memdesc:a5a7baaa896135caff7afcb7417c19098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union of <code>left</code> and <code>right</code> as if by <code>union_of(left, right);</code> <br /></td></tr>
<tr class="separator:a5a7baaa896135caff7afcb7417c19098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deddcddae90a6b646a3fe6e001c4798"><td class="memTemplParams" colspan="2"><a id="a1deddcddae90a6b646a3fe6e001c4798"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a1deddcddae90a6b646a3fe6e001c4798"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a1deddcddae90a6b646a3fe6e001c4798">operator+=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&amp;right)</td></tr>
<tr class="memdesc:a1deddcddae90a6b646a3fe6e001c4798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union of <code>left</code> and <code>right</code> as if by <code>left = (left + right);</code> <br /></td></tr>
<tr class="separator:a1deddcddae90a6b646a3fe6e001c4798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8509a97f2ab974f474ff159df81f3cf4"><td class="memTemplParams" colspan="2"><a id="a8509a97f2ab974f474ff159df81f3cf4"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a8509a97f2ab974f474ff159df81f3cf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a8509a97f2ab974f474ff159df81f3cf4">operator+=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:a8509a97f2ab974f474ff159df81f3cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union of <code>left</code> and <code>right</code> as if by <code>left = (left + right);</code> <br /></td></tr>
<tr class="separator:a8509a97f2ab974f474ff159df81f3cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb69f9f44348c769a049cd0d68e08e"><td class="memTemplParams" colspan="2"><a id="a1eeb69f9f44348c769a049cd0d68e08e"></a>
template&lt;class T , class U , class  = std::enable_if_t&lt;		detail::is_any_set_v&lt;std::decay_t&lt;T&gt;&gt;		and std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;	&gt;&gt; </td></tr>
<tr class="memitem:a1eeb69f9f44348c769a049cd0d68e08e"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a1eeb69f9f44348c769a049cd0d68e08e">operator|</a> (T &amp;&amp;left, U &amp;&amp;right)</td></tr>
<tr class="memdesc:a1eeb69f9f44348c769a049cd0d68e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union of <code>left</code> and <code>right</code> as if by <code>union_of(left, right);</code> <br /></td></tr>
<tr class="separator:a1eeb69f9f44348c769a049cd0d68e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172cb3928fca0ffe2f1d450d79762f2f"><td class="memTemplParams" colspan="2"><a id="a172cb3928fca0ffe2f1d450d79762f2f"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a172cb3928fca0ffe2f1d450d79762f2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a172cb3928fca0ffe2f1d450d79762f2f">operator|=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&amp;right)</td></tr>
<tr class="memdesc:a172cb3928fca0ffe2f1d450d79762f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union of <code>left</code> and <code>right</code> as if by <code>left = (left + right);</code> <br /></td></tr>
<tr class="separator:a172cb3928fca0ffe2f1d450d79762f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2c4808bbdf0ec7b2f28978952b944f"><td class="memTemplParams" colspan="2"><a id="a4c2c4808bbdf0ec7b2f28978952b944f"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a4c2c4808bbdf0ec7b2f28978952b944f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a4c2c4808bbdf0ec7b2f28978952b944f">operator|=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:a4c2c4808bbdf0ec7b2f28978952b944f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the union of <code>left</code> and <code>right</code> as if by <code>left = (left + right);</code> <br /></td></tr>
<tr class="separator:a4c2c4808bbdf0ec7b2f28978952b944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Intersection Operators</div></td></tr>
<tr class="memitem:a327d3ad749015de1688c54ce7c1001be"><td class="memTemplParams" colspan="2"><a id="a327d3ad749015de1688c54ce7c1001be"></a>
template&lt;class T , class U , class  = std::enable_if_t&lt;		detail::is_any_set_v&lt;std::decay_t&lt;T&gt;&gt;		and std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;	&gt;&gt; </td></tr>
<tr class="memitem:a327d3ad749015de1688c54ce7c1001be"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a327d3ad749015de1688c54ce7c1001be">operator &amp;</a> (T &amp;&amp;left, U &amp;&amp;right)</td></tr>
<tr class="memdesc:a327d3ad749015de1688c54ce7c1001be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection of <code>left</code> and <code>right</code> as if by <code>intersection_of(left, right);</code> <br /></td></tr>
<tr class="separator:a327d3ad749015de1688c54ce7c1001be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca75edf17d0e51f5bb143ed77500b9"><td class="memTemplParams" colspan="2"><a id="a39ca75edf17d0e51f5bb143ed77500b9"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a39ca75edf17d0e51f5bb143ed77500b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a39ca75edf17d0e51f5bb143ed77500b9">operator &amp;=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&amp;right)</td></tr>
<tr class="memdesc:a39ca75edf17d0e51f5bb143ed77500b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection of <code>left</code> and <code>right</code> as if by <code>left = (left &amp; right);</code> <br /></td></tr>
<tr class="separator:a39ca75edf17d0e51f5bb143ed77500b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a451a7b0f731a0ffa5e4b78f82b24"><td class="memTemplParams" colspan="2"><a id="a643a451a7b0f731a0ffa5e4b78f82b24"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a643a451a7b0f731a0ffa5e4b78f82b24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a643a451a7b0f731a0ffa5e4b78f82b24">operator &amp;=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:a643a451a7b0f731a0ffa5e4b78f82b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection of <code>left</code> and <code>right</code> as if by <code>left = (left &amp; right);</code> <br /></td></tr>
<tr class="separator:a643a451a7b0f731a0ffa5e4b78f82b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Difference Operators</div></td></tr>
<tr class="memitem:ad7f4ea37528709acff9b1aad69055da7"><td class="memTemplParams" colspan="2"><a id="ad7f4ea37528709acff9b1aad69055da7"></a>
template&lt;class T , class U , class  = std::enable_if_t&lt;		detail::is_any_set_v&lt;std::decay_t&lt;T&gt;&gt;		and std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;	&gt;&gt; </td></tr>
<tr class="memitem:ad7f4ea37528709acff9b1aad69055da7"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#ad7f4ea37528709acff9b1aad69055da7">operator-</a> (T &amp;&amp;left, U &amp;&amp;right)</td></tr>
<tr class="memdesc:ad7f4ea37528709acff9b1aad69055da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (asymmetric) difference of <code>left</code> and <code>right</code> as if by <code>difference_of(left, right);</code> <br /></td></tr>
<tr class="separator:ad7f4ea37528709acff9b1aad69055da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae120b58ea4f7e6f308b5ba52e3ef2c6e"><td class="memTemplParams" colspan="2"><a id="ae120b58ea4f7e6f308b5ba52e3ef2c6e"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:ae120b58ea4f7e6f308b5ba52e3ef2c6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#ae120b58ea4f7e6f308b5ba52e3ef2c6e">operator-=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&amp;right)</td></tr>
<tr class="memdesc:ae120b58ea4f7e6f308b5ba52e3ef2c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (asymmetric) difference of <code>left</code> and <code>right</code> as if by <code>left = (left - right);</code> <br /></td></tr>
<tr class="separator:ae120b58ea4f7e6f308b5ba52e3ef2c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026b1c469842543eaf37361948c25f3d"><td class="memTemplParams" colspan="2"><a id="a026b1c469842543eaf37361948c25f3d"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a026b1c469842543eaf37361948c25f3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a026b1c469842543eaf37361948c25f3d">operator-=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:a026b1c469842543eaf37361948c25f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (asymmetric) difference of <code>left</code> and <code>right</code> as if by <code>left = (left - right);</code> <br /></td></tr>
<tr class="separator:a026b1c469842543eaf37361948c25f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set Symmetric Difference Operators</div></td></tr>
<tr class="memitem:a6699af84ba64383594d13c3b03f42511"><td class="memTemplParams" colspan="2"><a id="a6699af84ba64383594d13c3b03f42511"></a>
template&lt;class T , class U , class  = std::enable_if_t&lt;		detail::is_any_set_v&lt;std::decay_t&lt;T&gt;&gt;		and std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;	&gt;&gt; </td></tr>
<tr class="memitem:a6699af84ba64383594d13c3b03f42511"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a6699af84ba64383594d13c3b03f42511">operator^</a> (T &amp;&amp;left, U &amp;&amp;right)</td></tr>
<tr class="memdesc:a6699af84ba64383594d13c3b03f42511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the symmetric difference of <code>left</code> and <code>right</code> as if by <code>symmetric_difference_of(left, right);</code> <br /></td></tr>
<tr class="separator:a6699af84ba64383594d13c3b03f42511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eed725c53c46302321d78275b2066c"><td class="memTemplParams" colspan="2"><a id="ae2eed725c53c46302321d78275b2066c"></a>
template&lt;class H , class E , class A , class U , class  = std::enable_if_t&lt;std::is_same_v&lt;AnySet&lt;H, E, A&gt;, std::decay_t&lt;U&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae2eed725c53c46302321d78275b2066c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#ae2eed725c53c46302321d78275b2066c">operator^=</a> (<a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, U &amp;&amp;right)</td></tr>
<tr class="memdesc:ae2eed725c53c46302321d78275b2066c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the symmetric difference of <code>left</code> and <code>right</code> as if by <code>left = (left ^ right);</code> <br /></td></tr>
<tr class="separator:ae2eed725c53c46302321d78275b2066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subset/Superset Operators</div></td></tr>
<tr class="memitem:ab314ecec74e7d3f1a618f264d671a104"><td class="memTemplParams" colspan="2"><a id="ab314ecec74e7d3f1a618f264d671a104"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:ab314ecec74e7d3f1a618f264d671a104"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#ab314ecec74e7d3f1a618f264d671a104">operator&lt;=</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:ab314ecec74e7d3f1a618f264d671a104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantically equivalent to <code>is_subset_of(left, right);</code>. <br /></td></tr>
<tr class="separator:ab314ecec74e7d3f1a618f264d671a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7626b7f36ab99a415038615ccfa28005"><td class="memTemplParams" colspan="2"><a id="a7626b7f36ab99a415038615ccfa28005"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:a7626b7f36ab99a415038615ccfa28005"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a7626b7f36ab99a415038615ccfa28005">operator&lt;</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:a7626b7f36ab99a415038615ccfa28005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantically equivalent to <code>is_subset_of(left, right) &amp;&amp; !(left.size() == right.size());</code>. <br /></td></tr>
<tr class="separator:a7626b7f36ab99a415038615ccfa28005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0470cca3d641507e8d739a1762dc7e3"><td class="memTemplParams" colspan="2"><a id="af0470cca3d641507e8d739a1762dc7e3"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:af0470cca3d641507e8d739a1762dc7e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#af0470cca3d641507e8d739a1762dc7e3">operator&gt;=</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:af0470cca3d641507e8d739a1762dc7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantically equivalent to <code>is_superset_of(left, right);</code>. <br /></td></tr>
<tr class="separator:af0470cca3d641507e8d739a1762dc7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37ebf855cae612b0a92fc6d6482b931"><td class="memTemplParams" colspan="2"><a id="aa37ebf855cae612b0a92fc6d6482b931"></a>
template&lt;class H , class E , class A &gt; </td></tr>
<tr class="memitem:aa37ebf855cae612b0a92fc6d6482b931"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#aa37ebf855cae612b0a92fc6d6482b931">operator&gt;</a> (const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;left, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;right)</td></tr>
<tr class="memdesc:aa37ebf855cae612b0a92fc6d6482b931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantically equivalent to <code>is_subset_of(left, right) &amp;&amp; !(left.size() == right.size());</code>. <br /></td></tr>
<tr class="separator:aa37ebf855cae612b0a92fc6d6482b931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream Insertion Operators</div></td></tr>
<tr class="memitem:abd9128e5f67276567f2422be2a9871b0"><td class="memTemplParams" colspan="2"><a id="abd9128e5f67276567f2422be2a9871b0"></a>
template&lt;class H , class E , class C &gt; </td></tr>
<tr class="memitem:abd9128e5f67276567f2422be2a9871b0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#abd9128e5f67276567f2422be2a9871b0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, C &gt; &amp;set)</td></tr>
<tr class="memdesc:abd9128e5f67276567f2422be2a9871b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instance to the std::ostream <code>os</code>. <br /></td></tr>
<tr class="separator:abd9128e5f67276567f2422be2a9871b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extra Hash Utilities</div></td></tr>
<tr class="memitem:aada0d814d4ed2fd52a4348ecf10d7389"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacete.html#aada0d814d4ed2fd52a4348ecf10d7389">hash_combine</a> (std::size_t first, std::size_t second)</td></tr>
<tr class="memdesc:aada0d814d4ed2fd52a4348ecf10d7389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two hash values using a formula that is compatible with <a class="el" href="namespacete.html#a114cb03cfc54ca8480d50fbf9f4cd0ef" title="Combine an arbitrary number of hash values using a formula that is compatible with boost::hash_combin...">boost::hash_combine()</a>.  <a href="#aada0d814d4ed2fd52a4348ecf10d7389">More...</a><br /></td></tr>
<tr class="separator:aada0d814d4ed2fd52a4348ecf10d7389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114cb03cfc54ca8480d50fbf9f4cd0ef"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class ... Args, class  = std::enable_if&lt;		(sizeof...(Args) &gt; 0u&gt; </td></tr>
<tr class="memitem:a114cb03cfc54ca8480d50fbf9f4cd0ef"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacete.html#a114cb03cfc54ca8480d50fbf9f4cd0ef">hash_combine</a> (T first, U second, Args ... args)</td></tr>
<tr class="memdesc:a114cb03cfc54ca8480d50fbf9f4cd0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine an arbitrary number of hash values using a formula that is compatible with <a class="el" href="namespacete.html#a114cb03cfc54ca8480d50fbf9f4cd0ef" title="Combine an arbitrary number of hash values using a formula that is compatible with boost::hash_combin...">boost::hash_combine()</a>.  <a href="#a114cb03cfc54ca8480d50fbf9f4cd0ef">More...</a><br /></td></tr>
<tr class="separator:a114cb03cfc54ca8480d50fbf9f4cd0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Casts and Accessors</div></td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab2492f1240f4a5089141900d2820dcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2492f1240f4a5089141900d2820dcc3">&#9670;&nbsp;</a></span>difference_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::decay_t&lt;T&gt; te::difference_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;...&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (asymmetric) difference of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances. </p>
<p>All arguments (<code>first</code> and <code>args</code>...) must be <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances with the same <code>HashFn</code> and <code>KeyEqual</code> values.</p>
<dl class="section note"><dt>Note</dt><dd>Set membership is determined using the shared <code>KeyEqual</code> function, not necessarily operator==.</dd>
<dd>
RValue <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances passed to this function will be left in a valid but unspecified state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- the first set in the group. </td></tr>
    <tr><td class="paramname">args</td><td>- the other sets in the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set (asymmetric) difference of <code>first</code> and <code>args</code>.... </dd></dl>

</div>
</div>
<a id="aada0d814d4ed2fd52a4348ecf10d7389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada0d814d4ed2fd52a4348ecf10d7389">&#9670;&nbsp;</a></span>hash_combine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t te::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine two hash values using a formula that is compatible with <a class="el" href="namespacete.html#a114cb03cfc54ca8480d50fbf9f4cd0ef" title="Combine an arbitrary number of hash values using a formula that is compatible with boost::hash_combin...">boost::hash_combine()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function is not order agnostic with respect to its arguments. That is, the returned hash value can change if the argument order changes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- First hash value. </td></tr>
    <tr><td class="paramname">second</td><td>- Second hash value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A hash value obtained from combining the two given hash values. </dd></dl>

</div>
</div>
<a id="a114cb03cfc54ca8480d50fbf9f4cd0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114cb03cfc54ca8480d50fbf9f4cd0ef">&#9670;&nbsp;</a></span>hash_combine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U , class ... Args, class  = std::enable_if&lt;		(sizeof...(Args) &gt; 0u&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t te::hash_combine </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine an arbitrary number of hash values using a formula that is compatible with <a class="el" href="namespacete.html#a114cb03cfc54ca8480d50fbf9f4cd0ef" title="Combine an arbitrary number of hash values using a formula that is compatible with boost::hash_combin...">boost::hash_combine()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function is not order agnostic with respect to its arguments. That is, the returned hash value can change if the argument order changes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- First hash value. </td></tr>
    <tr><td class="paramname">second</td><td>- Second hash value. </td></tr>
    <tr><td class="paramname">args</td><td>- Other hash values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A hash value obtained from combining the given hash values. </dd></dl>

</div>
</div>
<a id="a76f7b687336b2d915149f96ab2f46d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f7b687336b2d915149f96ab2f46d43">&#9670;&nbsp;</a></span>intersection_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::decay_t&lt;T&gt; te::intersection_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the intersection of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances. </p>
<p>All arguments (<code>first</code> and <code>args</code>...) must be <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances with the same <code>HashFn</code> and <code>KeyEqual</code> values.</p>
<dl class="section note"><dt>Note</dt><dd>Set membership is determined using the shared <code>KeyEqual</code> function, not necessarily operator==.</dd>
<dd>
RValue <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances passed to this function will be left in a valid but unspecified state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- the first set in the group. </td></tr>
    <tr><td class="paramname">args</td><td>- the other sets in the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set intersection of <code>first</code> and <code>args</code>.... </dd></dl>

</div>
</div>
<a id="a8c5d37b813da99bc5717fef4f6c6b07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5d37b813da99bc5717fef4f6c6b07a">&#9670;&nbsp;</a></span>is_subset_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class H , class E , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool te::is_subset_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>super</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether <code>sub</code> is a subset of <code>super</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>- The set to be considered the subset of <code>super</code>. </td></tr>
    <tr><td class="paramname">super</td><td>- The set to be considered the superset of <code>sub</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Set membership is determined using the shared <code>KeyEqual</code> function, not necessarily operator==.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>sub</code> is a subset of <code>super</code>. </dd></dl>

</div>
</div>
<a id="af803743f099b520c33c716952839df1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af803743f099b520c33c716952839df1d">&#9670;&nbsp;</a></span>is_superset_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class H , class E , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool te::is_superset_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>super</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structte_1_1AnySet.html">AnySet</a>&lt; H, E, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether <code>super</code> is a superset of <code>sub</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super</td><td>- The set to be considered the superset of <code>sub</code>. </td></tr>
    <tr><td class="paramname">sub</td><td>- The set to be considered the subset of <code>super</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Set membership is determined using the shared <code>KeyEqual</code> function, not necessarily operator==.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>super</code> is a superset of <code>sub</code>. </dd></dl>

</div>
</div>
<a id="a64a1eea7d24abfebac401d200d4aa33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a1eea7d24abfebac401d200d4aa33d">&#9670;&nbsp;</a></span>symmetric_difference_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::decay_t&lt;T&gt; te::symmetric_difference_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the symmetric difference of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances. </p>
<p>All arguments (<code>first</code> and <code>args</code>...) must be <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances with the same <code>HashFn</code> and <code>KeyEqual</code> values.</p>
<dl class="section note"><dt>Note</dt><dd>Set membership is determined using the shared <code>KeyEqual</code> function, not necessarily operator==.</dd>
<dd>
RValue <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances passed to this function will be left in a valid but unspecified state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- the first set in the group. </td></tr>
    <tr><td class="paramname">args</td><td>- the other sets in the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set symmetric difference of <code>first</code> and <code>args</code>.... </dd></dl>

</div>
</div>
<a id="a96af90d19e85c0a21e7016b9da6647e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96af90d19e85c0a21e7016b9da6647e2">&#9670;&nbsp;</a></span>union_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::decay_t&lt;T&gt; te::union_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the union of a group of <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances. </p>
<p>All arguments (<code>first</code> and <code>args</code>...) must be <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances with the same <code>HashFn</code> and <code>KeyEqual</code> values.</p>
<dl class="section note"><dt>Note</dt><dd>Set membership is determined using the shared <code>KeyEqual</code> function, not necessarily operator==.</dd>
<dd>
RValue <a class="el" href="structte_1_1AnySet.html" title="AnySet is an associative container that contains a set of unique objects of any constructible type...">AnySet</a> instances passed to this function will be left in a valid but unspecified state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- the first set in the group. </td></tr>
    <tr><td class="paramname">args</td><td>- the other sets in the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set union of <code>first</code> and <code>args</code>.... </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
