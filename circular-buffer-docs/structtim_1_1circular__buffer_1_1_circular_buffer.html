<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: tim::circular_buffer::CircularBuffer&lt; T, Allocator &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tim</b></li><li class="navelem"><b>circular_buffer</b></li><li class="navelem"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structtim_1_1circular__buffer_1_1_circular_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tim::circular_buffer::CircularBuffer&lt; T, Allocator &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A sequence container that encapsulates a resizable ring/circular buffer.  
 <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_circular_buffer_8hpp_source.html">tim/circular-buffer/CircularBuffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tim::circular_buffer::CircularBuffer&lt; T, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structtim_1_1circular__buffer_1_1_circular_buffer.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43e759457fc53426ce63765ee375567a"><td class="memItemLeft" align="right" valign="top"><a id="a43e759457fc53426ce63765ee375567a" name="a43e759457fc53426ce63765ee375567a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a43e759457fc53426ce63765ee375567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a7bb87f57fd47b1a0e639f739da683"><td class="memItemLeft" align="right" valign="top"><a id="ad7a7bb87f57fd47b1a0e639f739da683" name="ad7a7bb87f57fd47b1a0e639f739da683"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:ad7a7bb87f57fd47b1a0e639f739da683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae988f1f74f04509b29175a78eed096da"><td class="memItemLeft" align="right" valign="top"><a id="ae988f1f74f04509b29175a78eed096da" name="ae988f1f74f04509b29175a78eed096da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename alloc_traits::size_type</td></tr>
<tr class="separator:ae988f1f74f04509b29175a78eed096da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a3a567538a9fe5770db35639cfb9b"><td class="memItemLeft" align="right" valign="top"><a id="a838a3a567538a9fe5770db35639cfb9b" name="a838a3a567538a9fe5770db35639cfb9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename alloc_traits::difference_type</td></tr>
<tr class="separator:a838a3a567538a9fe5770db35639cfb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5baca717c070bde85af53fe6625012"><td class="memItemLeft" align="right" valign="top"><a id="a0c5baca717c070bde85af53fe6625012" name="a0c5baca717c070bde85af53fe6625012"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a0c5baca717c070bde85af53fe6625012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4dbd69db6208a0ab0ac8f79e8871c"><td class="memItemLeft" align="right" valign="top"><a id="a4af4dbd69db6208a0ab0ac8f79e8871c" name="a4af4dbd69db6208a0ab0ac8f79e8871c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:a4af4dbd69db6208a0ab0ac8f79e8871c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e6e7bcfa25083d9e40cfa190c67f9c"><td class="memItemLeft" align="right" valign="top"><a id="a37e6e7bcfa25083d9e40cfa190c67f9c" name="a37e6e7bcfa25083d9e40cfa190c67f9c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename alloc_traits::pointer</td></tr>
<tr class="separator:a37e6e7bcfa25083d9e40cfa190c67f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ed72c94f83bccbf859451fab3e9a25"><td class="memItemLeft" align="right" valign="top"><a id="a07ed72c94f83bccbf859451fab3e9a25" name="a07ed72c94f83bccbf859451fab3e9a25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename alloc_traits::const_pointer</td></tr>
<tr class="separator:a07ed72c94f83bccbf859451fab3e9a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be79ac4375714a7b2083269d14f6281"><td class="memItemLeft" align="right" valign="top"><a id="a4be79ac4375714a7b2083269d14f6281" name="a4be79ac4375714a7b2083269d14f6281"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">CircularBufferIterator</a>&lt; T, Allocator &gt;</td></tr>
<tr class="separator:a4be79ac4375714a7b2083269d14f6281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1116eed6acaac0c1b5e0f1017b5e6f"><td class="memItemLeft" align="right" valign="top"><a id="a0f1116eed6acaac0c1b5e0f1017b5e6f" name="a0f1116eed6acaac0c1b5e0f1017b5e6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">ConstCircularBufferIterator</a>&lt; T, Allocator &gt;</td></tr>
<tr class="separator:a0f1116eed6acaac0c1b5e0f1017b5e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1f01d928d82dc5ded83c3a269fb670"><td class="memItemLeft" align="right" valign="top"><a id="a9c1f01d928d82dc5ded83c3a269fb670" name="a9c1f01d928d82dc5ded83c3a269fb670"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a9c1f01d928d82dc5ded83c3a269fb670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea986b3c09bed79293ba7984386ee221"><td class="memItemLeft" align="right" valign="top"><a id="aea986b3c09bed79293ba7984386ee221" name="aea986b3c09bed79293ba7984386ee221"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:aea986b3c09bed79293ba7984386ee221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab485ce9de907ac9dbf87832299943f51"><td class="memItemLeft" align="right" valign="top"><a id="ab485ce9de907ac9dbf87832299943f51" name="ab485ce9de907ac9dbf87832299943f51"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>shape_type</b> = <a class="el" href="structtim_1_1circular__buffer_1_1_buffer_shape.html">BufferShape</a>&lt; size_type &gt;</td></tr>
<tr class="separator:ab485ce9de907ac9dbf87832299943f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3ebc26b39cb195efaf8fb69d5116bd0d"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a3ebc26b39cb195efaf8fb69d5116bd0d">~CircularBuffer</a> ()</td></tr>
<tr class="separator:a3ebc26b39cb195efaf8fb69d5116bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29c923debb07338f1e2f0cca90efb55"><td class="memItemLeft" align="right" valign="top"><a id="ad29c923debb07338f1e2f0cca90efb55" name="ad29c923debb07338f1e2f0cca90efb55"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>CircularBuffer</b> ()=default</td></tr>
<tr class="memdesc:ad29c923debb07338f1e2f0cca90efb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs an empty buffer with 0 capacity. <br /></td></tr>
<tr class="separator:ad29c923debb07338f1e2f0cca90efb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716159cc439fe225735d3788537b7d02"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a716159cc439fe225735d3788537b7d02">CircularBuffer</a> (const Allocator &amp;al) noexcept(std::is_nothrow_copy_constructible_v&lt; Allocator &gt;)</td></tr>
<tr class="memdesc:a716159cc439fe225735d3788537b7d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator alloc.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a716159cc439fe225735d3788537b7d02">More...</a><br /></td></tr>
<tr class="separator:a716159cc439fe225735d3788537b7d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead26539d3b7709dd37ea09b749a696c"><td class="memTemplParams" colspan="2">template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:aead26539d3b7709dd37ea09b749a696c"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aead26539d3b7709dd37ea09b749a696c">CircularBuffer</a> (TagType tag, const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="memdesc:aead26539d3b7709dd37ea09b749a696c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a copy of 'other' with the given allocator 'al' using the method specified by 'tag'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aead26539d3b7709dd37ea09b749a696c">More...</a><br /></td></tr>
<tr class="separator:aead26539d3b7709dd37ea09b749a696c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087d8fc24acb3f458c2718c40b721241"><td class="memTemplParams" colspan="2">template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt; &gt;  = true&gt; </td></tr>
<tr class="memitem:a087d8fc24acb3f458c2718c40b721241"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a087d8fc24acb3f458c2718c40b721241">CircularBuffer</a> (TagType tag, const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:a087d8fc24acb3f458c2718c40b721241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a copy of 'other' using the method specified by 'tag'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a087d8fc24acb3f458c2718c40b721241">More...</a><br /></td></tr>
<tr class="separator:a087d8fc24acb3f458c2718c40b721241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ebc01c465e2b01e53816fbf42ac96b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a91ebc01c465e2b01e53816fbf42ac96b">CircularBuffer</a> (const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;other, const Allocator &amp;al)</td></tr>
<tr class="memdesc:a91ebc01c465e2b01e53816fbf42ac96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a copy of 'other' with the given allocator 'al' as if by calling 'CircularBuffer(tags::optimized, other, al)'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a91ebc01c465e2b01e53816fbf42ac96b">More...</a><br /></td></tr>
<tr class="separator:a91ebc01c465e2b01e53816fbf42ac96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9c04f77060be59d9349d6ada607494"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a0f9c04f77060be59d9349d6ada607494">CircularBuffer</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0f9c04f77060be59d9349d6ada607494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a0f9c04f77060be59d9349d6ada607494">More...</a><br /></td></tr>
<tr class="separator:a0f9c04f77060be59d9349d6ada607494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a1dc7b8c5e6ff11c42d71e0ef803be"><td class="memTemplParams" colspan="2">template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt; &gt;  = true&gt; </td></tr>
<tr class="memitem:aa7a1dc7b8c5e6ff11c42d71e0ef803be"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa7a1dc7b8c5e6ff11c42d71e0ef803be">CircularBuffer</a> (TagType tag, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa7a1dc7b8c5e6ff11c42d71e0ef803be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged move constructor.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa7a1dc7b8c5e6ff11c42d71e0ef803be">More...</a><br /></td></tr>
<tr class="separator:aa7a1dc7b8c5e6ff11c42d71e0ef803be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6928dc88f1bdb9799ae55d459724de"><td class="memTemplParams" colspan="2">template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt; &gt;  = true&gt; </td></tr>
<tr class="memitem:a5b6928dc88f1bdb9799ae55d459724de"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a5b6928dc88f1bdb9799ae55d459724de">CircularBuffer</a> (TagType tag, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&amp;other, const Allocator &amp;al)</td></tr>
<tr class="memdesc:a5b6928dc88f1bdb9799ae55d459724de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged move constructor with custom allocator.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a5b6928dc88f1bdb9799ae55d459724de">More...</a><br /></td></tr>
<tr class="separator:a5b6928dc88f1bdb9799ae55d459724de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d1d7b1652c49185582cff027fae86c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13d1d7b1652c49185582cff027fae86c">CircularBuffer</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&amp;other, const Allocator &amp;alloc) noexcept</td></tr>
<tr class="memdesc:a13d1d7b1652c49185582cff027fae86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with custom allocator.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13d1d7b1652c49185582cff027fae86c">More...</a><br /></td></tr>
<tr class="separator:a13d1d7b1652c49185582cff027fae86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d973d0eb58173f340936786eef6203b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d973d0eb58173f340936786eef6203b">CircularBuffer</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_buffer_shape.html">shape_type</a> shape, const Allocator &amp;al) noexcept(std::is_nothrow_copy_constructible_v&lt; Allocator &gt;)</td></tr>
<tr class="memdesc:a8d973d0eb58173f340936786eef6203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape constructor.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d973d0eb58173f340936786eef6203b">More...</a><br /></td></tr>
<tr class="separator:a8d973d0eb58173f340936786eef6203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371706b742bd94bd4d4715a7699b001d"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a371706b742bd94bd4d4715a7699b001d">CircularBuffer</a> (std::initializer_list&lt; T &gt; init, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a371706b742bd94bd4d4715a7699b001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list constructor.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a371706b742bd94bd4d4715a7699b001d">More...</a><br /></td></tr>
<tr class="separator:a371706b742bd94bd4d4715a7699b001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfe3245c3c3ff1b9d2bb9007e777e2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a0cfe3245c3c3ff1b9d2bb9007e777e2f">CircularBuffer</a> (size_type count, const value_type &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a0cfe3245c3c3ff1b9d2bb9007e777e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with 'count' copies of elements with value 'value'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a0cfe3245c3c3ff1b9d2bb9007e777e2f">More...</a><br /></td></tr>
<tr class="separator:a0cfe3245c3c3ff1b9d2bb9007e777e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bbdeb4cce4f0991fc8ba5308cef84"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ac89bbdeb4cce4f0991fc8ba5308cef84">CircularBuffer</a> (size_type count, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:ac89bbdeb4cce4f0991fc8ba5308cef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with 'count' default-consrtucted elements.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ac89bbdeb4cce4f0991fc8ba5308cef84">More...</a><br /></td></tr>
<tr class="separator:ac89bbdeb4cce4f0991fc8ba5308cef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af9e3c6b822cedd481315cc2bf05c8fcf">CircularBuffer</a> (It first, It last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af9e3c6b822cedd481315cc2bf05c8fcf">More...</a><br /></td></tr>
<tr class="separator:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_same_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af9e3c6b822cedd481315cc2bf05c8fcf">CircularBuffer</a> (It first, It last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af9e3c6b822cedd481315cc2bf05c8fcf">More...</a><br /></td></tr>
<tr class="separator:af9e3c6b822cedd481315cc2bf05c8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade61eb49494a69ddad1588b8d7eab3fb"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ade61eb49494a69ddad1588b8d7eab3fb">CircularBuffer</a> (const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:ade61eb49494a69ddad1588b8d7eab3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ade61eb49494a69ddad1588b8d7eab3fb">More...</a><br /></td></tr>
<tr class="separator:ade61eb49494a69ddad1588b8d7eab3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad267b455d6727bcb19549c7f05906866"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ad267b455d6727bcb19549c7f05906866">operator=</a> (const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:ad267b455d6727bcb19549c7f05906866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ad267b455d6727bcb19549c7f05906866">More...</a><br /></td></tr>
<tr class="separator:ad267b455d6727bcb19549c7f05906866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2234113f2698a042e0bc1c2956dabc22"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a2234113f2698a042e0bc1c2956dabc22">operator=</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&amp;other) noexcept(propagate_on_container_move_assignment||is_always_equal)</td></tr>
<tr class="separator:a2234113f2698a042e0bc1c2956dabc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc292efb7a4493b4f69a399460004bac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#abc292efb7a4493b4f69a399460004bac">operator=</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:abc292efb7a4493b4f69a399460004bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list 'init'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#abc292efb7a4493b4f69a399460004bac">More...</a><br /></td></tr>
<tr class="separator:abc292efb7a4493b4f69a399460004bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054a8609d45d2f1bbc04b4cb6e73b4ba"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a054a8609d45d2f1bbc04b4cb6e73b4ba">assign</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a054a8609d45d2f1bbc04b4cb6e73b4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value value.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a054a8609d45d2f1bbc04b4cb6e73b4ba">More...</a><br /></td></tr>
<tr class="separator:a054a8609d45d2f1bbc04b4cb6e73b4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ebc7d868951bdd2da6ddd8561fd680"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:ad7ebc7d868951bdd2da6ddd8561fd680"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ad7ebc7d868951bdd2da6ddd8561fd680">assign</a> (It first, It last)</td></tr>
<tr class="memdesc:ad7ebc7d868951bdd2da6ddd8561fd680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last).  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ad7ebc7d868951bdd2da6ddd8561fd680">More...</a><br /></td></tr>
<tr class="separator:ad7ebc7d868951bdd2da6ddd8561fd680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14cb989d7b779dee25738111131dc17"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab14cb989d7b779dee25738111131dc17">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:ab14cb989d7b779dee25738111131dc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list 'init'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab14cb989d7b779dee25738111131dc17">More...</a><br /></td></tr>
<tr class="separator:ab14cb989d7b779dee25738111131dc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0297f2d8c63b22aadf06e537b92b40"><td class="memItemLeft" align="right" valign="top"><a id="a4d0297f2d8c63b22aadf06e537b92b40" name="a4d0297f2d8c63b22aadf06e537b92b40"></a>
constexpr allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept</td></tr>
<tr class="memdesc:a4d0297f2d8c63b22aadf06e537b92b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:a4d0297f2d8c63b22aadf06e537b92b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d2c872d6ed5746772b8b60890ee8b4"><td class="memItemLeft" align="right" valign="top"><a id="a77d2c872d6ed5746772b8b60890ee8b4" name="a77d2c872d6ed5746772b8b60890ee8b4"></a>
constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="memdesc:a77d2c872d6ed5746772b8b60890ee8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator to the first element of the buffer. <br  />
 <br /></td></tr>
<tr class="separator:a77d2c872d6ed5746772b8b60890ee8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e1c8ef1036f4af0b3e407a73c4ae6"><td class="memItemLeft" align="right" valign="top"><a id="a585e1c8ef1036f4af0b3e407a73c4ae6" name="a585e1c8ef1036f4af0b3e407a73c4ae6"></a>
constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="memdesc:a585e1c8ef1036f4af0b3e407a73c4ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element of the buffer. <br  />
 <br /></td></tr>
<tr class="separator:a585e1c8ef1036f4af0b3e407a73c4ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb38e3badf024d8979c7b5b5430a00"><td class="memItemLeft" align="right" valign="top"><a id="a35cb38e3badf024d8979c7b5b5430a00" name="a35cb38e3badf024d8979c7b5b5430a00"></a>
constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="memdesc:a35cb38e3badf024d8979c7b5b5430a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element of the buffer. <br  />
 <br /></td></tr>
<tr class="separator:a35cb38e3badf024d8979c7b5b5430a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aa8f9577ec50396dca0ce8106a335c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c">end</a> () noexcept</td></tr>
<tr class="memdesc:a83aa8f9577ec50396dca0ce8106a335c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator to the element following the last element of the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c">More...</a><br /></td></tr>
<tr class="separator:a83aa8f9577ec50396dca0ce8106a335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04836f6e6e58a1fc20d93354b7d5c9d1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a04836f6e6e58a1fc20d93354b7d5c9d1">end</a> () const noexcept</td></tr>
<tr class="memdesc:a04836f6e6e58a1fc20d93354b7d5c9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a04836f6e6e58a1fc20d93354b7d5c9d1">More...</a><br /></td></tr>
<tr class="separator:a04836f6e6e58a1fc20d93354b7d5c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c8b9cb4194d6e6dc1fceb1ba0bd777"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a09c8b9cb4194d6e6dc1fceb1ba0bd777">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a09c8b9cb4194d6e6dc1fceb1ba0bd777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a09c8b9cb4194d6e6dc1fceb1ba0bd777">More...</a><br /></td></tr>
<tr class="separator:a09c8b9cb4194d6e6dc1fceb1ba0bd777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477c8cd1839d955e4cf1795b0f3f77f5"><td class="memItemLeft" align="right" valign="top">constexpr reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a477c8cd1839d955e4cf1795b0f3f77f5">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a477c8cd1839d955e4cf1795b0f3f77f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reverse iterator to the first element of the reversed buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a477c8cd1839d955e4cf1795b0f3f77f5">More...</a><br /></td></tr>
<tr class="separator:a477c8cd1839d955e4cf1795b0f3f77f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbdeb4add5bed030203676fab6e28ae"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a9bbdeb4add5bed030203676fab6e28ae">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a9bbdeb4add5bed030203676fab6e28ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a9bbdeb4add5bed030203676fab6e28ae">More...</a><br /></td></tr>
<tr class="separator:a9bbdeb4add5bed030203676fab6e28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93223c4facf17c266e3ce129eab85d14"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a93223c4facf17c266e3ce129eab85d14">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a93223c4facf17c266e3ce129eab85d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a93223c4facf17c266e3ce129eab85d14">More...</a><br /></td></tr>
<tr class="separator:a93223c4facf17c266e3ce129eab85d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2c780d821edaf9e0c28f10d85ef3df"><td class="memItemLeft" align="right" valign="top">constexpr reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1a2c780d821edaf9e0c28f10d85ef3df">rend</a> () noexcept</td></tr>
<tr class="memdesc:a1a2c780d821edaf9e0c28f10d85ef3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reverse iterator to the element following the last element of the reversed buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1a2c780d821edaf9e0c28f10d85ef3df">More...</a><br /></td></tr>
<tr class="separator:a1a2c780d821edaf9e0c28f10d85ef3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9673040e5901313c464da3f57f2d9c67"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a9673040e5901313c464da3f57f2d9c67">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a9673040e5901313c464da3f57f2d9c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a9673040e5901313c464da3f57f2d9c67">More...</a><br /></td></tr>
<tr class="separator:a9673040e5901313c464da3f57f2d9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527dd6cb3b04c89e06a08bbd82976c7"><td class="memItemLeft" align="right" valign="top">constexpr const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af527dd6cb3b04c89e06a08bbd82976c7">crend</a> () const noexcept</td></tr>
<tr class="memdesc:af527dd6cb3b04c89e06a08bbd82976c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af527dd6cb3b04c89e06a08bbd82976c7">More...</a><br /></td></tr>
<tr class="separator:af527dd6cb3b04c89e06a08bbd82976c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5a3c654732cbb5d8090a7d26d9243d"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a3f5a3c654732cbb5d8090a7d26d9243d">operator[]</a> (size_type index)</td></tr>
<tr class="memdesc:a3f5a3c654732cbb5d8090a7d26d9243d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the element at specified location 'index'. No bounds checking is performed.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a3f5a3c654732cbb5d8090a7d26d9243d">More...</a><br /></td></tr>
<tr class="separator:a3f5a3c654732cbb5d8090a7d26d9243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe5d082fad35322c9be31665a164f4"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6dfe5d082fad35322c9be31665a164f4">operator[]</a> (size_type index) const</td></tr>
<tr class="memdesc:a6dfe5d082fad35322c9be31665a164f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at specified location 'index'. No bounds checking is performed.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6dfe5d082fad35322c9be31665a164f4">More...</a><br /></td></tr>
<tr class="separator:a6dfe5d082fad35322c9be31665a164f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eae3a0874d1754fa34391de19b488a"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a37eae3a0874d1754fa34391de19b488a">at</a> (size_type index)</td></tr>
<tr class="memdesc:a37eae3a0874d1754fa34391de19b488a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the element at specified location 'index', with bounds checking.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a37eae3a0874d1754fa34391de19b488a">More...</a><br /></td></tr>
<tr class="separator:a37eae3a0874d1754fa34391de19b488a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319a56d9d22a6a3fe41dbfd85d0764c3"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a319a56d9d22a6a3fe41dbfd85d0764c3">at</a> (size_type index) const</td></tr>
<tr class="memdesc:a319a56d9d22a6a3fe41dbfd85d0764c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at specified location 'index', with bounds checking.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a319a56d9d22a6a3fe41dbfd85d0764c3">More...</a><br /></td></tr>
<tr class="separator:a319a56d9d22a6a3fe41dbfd85d0764c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d050f0ec9d0b3d8afe1e8d6dcfcdab"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a89d050f0ec9d0b3d8afe1e8d6dcfcdab">front</a> () const</td></tr>
<tr class="memdesc:a89d050f0ec9d0b3d8afe1e8d6dcfcdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the first element in the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a89d050f0ec9d0b3d8afe1e8d6dcfcdab">More...</a><br /></td></tr>
<tr class="separator:a89d050f0ec9d0b3d8afe1e8d6dcfcdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebefe9e20033161bc1f88182ec58b03"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1ebefe9e20033161bc1f88182ec58b03">front</a> ()</td></tr>
<tr class="memdesc:a1ebefe9e20033161bc1f88182ec58b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the first element in the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1ebefe9e20033161bc1f88182ec58b03">More...</a><br /></td></tr>
<tr class="separator:a1ebefe9e20033161bc1f88182ec58b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a8a8894dba794ac119074fcbb95176"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a76a8a8894dba794ac119074fcbb95176">back</a> () const</td></tr>
<tr class="memdesc:a76a8a8894dba794ac119074fcbb95176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the last element in the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a76a8a8894dba794ac119074fcbb95176">More...</a><br /></td></tr>
<tr class="separator:a76a8a8894dba794ac119074fcbb95176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae700a11c77bd8c6e93568991dc831c04"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae700a11c77bd8c6e93568991dc831c04">back</a> ()</td></tr>
<tr class="memdesc:ae700a11c77bd8c6e93568991dc831c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the last element in the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae700a11c77bd8c6e93568991dc831c04">More...</a><br /></td></tr>
<tr class="separator:ae700a11c77bd8c6e93568991dc831c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870c2775e2ca7f70ac254637595b7c32"><td class="memItemLeft" align="right" valign="top"><a id="a870c2775e2ca7f70ac254637595b7c32" name="a870c2775e2ca7f70ac254637595b7c32"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="memdesc:a870c2775e2ca7f70ac254637595b7c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for. <br /></td></tr>
<tr class="separator:a870c2775e2ca7f70ac254637595b7c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a8d4b9a0f71bc872bbf9b2453f2324"><td class="memItemLeft" align="right" valign="top"><a id="a47a8d4b9a0f71bc872bbf9b2453f2324" name="a47a8d4b9a0f71bc872bbf9b2453f2324"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:a47a8d4b9a0f71bc872bbf9b2453f2324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>). <br /></td></tr>
<tr class="separator:a47a8d4b9a0f71bc872bbf9b2453f2324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593db6d133f6f2e7802666c55ca73cd4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a593db6d133f6f2e7802666c55ca73cd4">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a593db6d133f6f2e7802666c55ca73cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a> == <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a593db6d133f6f2e7802666c55ca73cd4">More...</a><br /></td></tr>
<tr class="separator:a593db6d133f6f2e7802666c55ca73cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9908fd82e8fb9d15b5a8b7eceb73251"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab9908fd82e8fb9d15b5a8b7eceb73251">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:ab9908fd82e8fb9d15b5a8b7eceb73251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) for the largest possible container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab9908fd82e8fb9d15b5a8b7eceb73251">More...</a><br /></td></tr>
<tr class="separator:ab9908fd82e8fb9d15b5a8b7eceb73251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13463b6672db6727101be4931c605e36"><td class="memItemLeft" align="right" valign="top"><a id="a13463b6672db6727101be4931c605e36" name="a13463b6672db6727101be4931c605e36"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><b>begin_index</b> () const</td></tr>
<tr class="memdesc:a13463b6672db6727101be4931c605e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into the raw (physical) memory buffer of the first element (the physical index of logical index 0). <br /></td></tr>
<tr class="separator:a13463b6672db6727101be4931c605e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4264f704119f7fed2b667a67a0521ba0"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0">end_index</a> () const</td></tr>
<tr class="memdesc:a4264f704119f7fed2b667a67a0521ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into the raw memory buffer of the element following the last element in the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0">More...</a><br /></td></tr>
<tr class="separator:a4264f704119f7fed2b667a67a0521ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef9ed422e6a6d76b6f2ed964ca42de"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af8ef9ed422e6a6d76b6f2ed964ca42de">clear</a> () noexcept</td></tr>
<tr class="memdesc:af8ef9ed422e6a6d76b6f2ed964ca42de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af8ef9ed422e6a6d76b6f2ed964ca42de">More...</a><br /></td></tr>
<tr class="separator:af8ef9ed422e6a6d76b6f2ed964ca42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d8702ace99b0900b69767a97da4ce8"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af0d8702ace99b0900b69767a97da4ce8">reserve</a> (size_type new_cap)</td></tr>
<tr class="memdesc:af0d8702ace99b0900b69767a97da4ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the buffer to a value that's greater or equal to new_cap.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af0d8702ace99b0900b69767a97da4ce8">More...</a><br /></td></tr>
<tr class="separator:af0d8702ace99b0900b69767a97da4ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a645554b9caa2f8ab91bf41c51d578"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a57a645554b9caa2f8ab91bf41c51d578">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a57a645554b9caa2f8ab91bf41c51d578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a57a645554b9caa2f8ab91bf41c51d578">More...</a><br /></td></tr>
<tr class="separator:a57a645554b9caa2f8ab91bf41c51d578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2973ef10e5a2738f7a915785427ca5"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a8d2973ef10e5a2738f7a915785427ca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5">insert_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, It first, It last)</td></tr>
<tr class="memdesc:a8d2973ef10e5a2738f7a915785427ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5">More...</a><br /></td></tr>
<tr class="separator:a8d2973ef10e5a2738f7a915785427ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2973ef10e5a2738f7a915785427ca5"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a8d2973ef10e5a2738f7a915785427ca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5">insert_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, It first, It last)</td></tr>
<tr class="memdesc:a8d2973ef10e5a2738f7a915785427ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5">More...</a><br /></td></tr>
<tr class="separator:a8d2973ef10e5a2738f7a915785427ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a741c8e1f5921a635a2799749f3267a"><td class="memTemplParams" colspan="2">template&lt;class U , std::enable_if_t&lt; std::is_same_v&lt; T, std::remove_cvref_t&lt; U &gt; &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a6a741c8e1f5921a635a2799749f3267a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6a741c8e1f5921a635a2799749f3267a">insert_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, U &amp;&amp;value)</td></tr>
<tr class="memdesc:a6a741c8e1f5921a635a2799749f3267a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6a741c8e1f5921a635a2799749f3267a">More...</a><br /></td></tr>
<tr class="separator:a6a741c8e1f5921a635a2799749f3267a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ef209df4db1de90a16d8fc51e06b80"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a26ef209df4db1de90a16d8fc51e06b80">insert_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a26ef209df4db1de90a16d8fc51e06b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts 'count' copies of the given element before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a26ef209df4db1de90a16d8fc51e06b80">More...</a><br /></td></tr>
<tr class="separator:a26ef209df4db1de90a16d8fc51e06b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b6772a6b403a42c74b496edbe4b3c3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae6b6772a6b403a42c74b496edbe4b3c3">insert_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:ae6b6772a6b403a42c74b496edbe4b3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements from the initialize list before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae6b6772a6b403a42c74b496edbe4b3c3">More...</a><br /></td></tr>
<tr class="separator:ae6b6772a6b403a42c74b496edbe4b3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb">insert_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, It first, It last)</td></tr>
<tr class="memdesc:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb">More...</a><br /></td></tr>
<tr class="separator:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb">insert_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, It first, It last)</td></tr>
<tr class="memdesc:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb">More...</a><br /></td></tr>
<tr class="separator:a245dd4f06dc1ef6bdffc56481e7915bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743b3fa8cfee1b831ffd8ce783f87a95"><td class="memTemplParams" colspan="2">template&lt;class U , std::enable_if_t&lt; std::is_same_v&lt; T, std::remove_cvref_t&lt; U &gt; &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a743b3fa8cfee1b831ffd8ce783f87a95"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a743b3fa8cfee1b831ffd8ce783f87a95">insert_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, U &amp;&amp;value)</td></tr>
<tr class="memdesc:a743b3fa8cfee1b831ffd8ce783f87a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted ivalue.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a743b3fa8cfee1b831ffd8ce783f87a95">More...</a><br /></td></tr>
<tr class="separator:a743b3fa8cfee1b831ffd8ce783f87a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c3138d29b59cc28c524854502292be"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af1c3138d29b59cc28c524854502292be">insert_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:af1c3138d29b59cc28c524854502292be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts 'count' copies of the given element before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af1c3138d29b59cc28c524854502292be">More...</a><br /></td></tr>
<tr class="separator:af1c3138d29b59cc28c524854502292be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077e56576efcc2a54a282d983292a7e5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a077e56576efcc2a54a282d983292a7e5">insert_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a077e56576efcc2a54a282d983292a7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements from the initialize list before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a077e56576efcc2a54a282d983292a7e5">More...</a><br /></td></tr>
<tr class="separator:a077e56576efcc2a54a282d983292a7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4911308699818bf18dcf6be161d8e2c"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:aa4911308699818bf18dcf6be161d8e2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa4911308699818bf18dcf6be161d8e2c">insert</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, It first, It last)</td></tr>
<tr class="memdesc:aa4911308699818bf18dcf6be161d8e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa4911308699818bf18dcf6be161d8e2c">More...</a><br /></td></tr>
<tr class="separator:aa4911308699818bf18dcf6be161d8e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8701529f819f64fb3128922db5b0c9da"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8701529f819f64fb3128922db5b0c9da">insert</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a8701529f819f64fb3128922db5b0c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements from the initialize list before pos.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8701529f819f64fb3128922db5b0c9da">More...</a><br /></td></tr>
<tr class="separator:a8701529f819f64fb3128922db5b0c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565f99e98cf0e5c3903bc3fdba4d2d2a"><td class="memTemplParams" colspan="2">template&lt;class U , std::enable_if_t&lt; std::is_same_v&lt; T, std::remove_cvref_t&lt; U &gt; &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a565f99e98cf0e5c3903bc3fdba4d2d2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a565f99e98cf0e5c3903bc3fdba4d2d2a">insert</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, U &amp;&amp;value)</td></tr>
<tr class="memdesc:a565f99e98cf0e5c3903bc3fdba4d2d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element before pos.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a565f99e98cf0e5c3903bc3fdba4d2d2a">More...</a><br /></td></tr>
<tr class="separator:a565f99e98cf0e5c3903bc3fdba4d2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d88c759ae26aedd69c15c4953872e7d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6d88c759ae26aedd69c15c4953872e7d">insert</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a6d88c759ae26aedd69c15c4953872e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts 'count' copies of the given element before pos.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6d88c759ae26aedd69c15c4953872e7d">More...</a><br /></td></tr>
<tr class="separator:a6d88c759ae26aedd69c15c4953872e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23c504881658420baa02968e1b18582"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:ab23c504881658420baa02968e1b18582"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab23c504881658420baa02968e1b18582">emplace</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab23c504881658420baa02968e1b18582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the given element before pos.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab23c504881658420baa02968e1b18582">More...</a><br /></td></tr>
<tr class="separator:ab23c504881658420baa02968e1b18582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae072c351a8994d40922cef40d08a2216"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:ae072c351a8994d40922cef40d08a2216"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae072c351a8994d40922cef40d08a2216">emplace_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae072c351a8994d40922cef40d08a2216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the given element before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae072c351a8994d40922cef40d08a2216">More...</a><br /></td></tr>
<tr class="separator:ae072c351a8994d40922cef40d08a2216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aa5aefe5672916a6ed3f3c92b0216d"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a29aa5aefe5672916a6ed3f3c92b0216d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a29aa5aefe5672916a6ed3f3c92b0216d">emplace_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a29aa5aefe5672916a6ed3f3c92b0216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the given element before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a29aa5aefe5672916a6ed3f3c92b0216d">More...</a><br /></td></tr>
<tr class="separator:a29aa5aefe5672916a6ed3f3c92b0216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e5cfe043921bd673d283ec0b2ec1fc"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:ac1e5cfe043921bd673d283ec0b2ec1fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ac1e5cfe043921bd673d283ec0b2ec1fc">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac1e5cfe043921bd673d283ec0b2ec1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the given element at the past-the-end position in the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ac1e5cfe043921bd673d283ec0b2ec1fc">More...</a><br /></td></tr>
<tr class="separator:ac1e5cfe043921bd673d283ec0b2ec1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020d6ddc895150cbf08e4a7a5afd9e3f"><td class="memTemplParams" colspan="2">template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a020d6ddc895150cbf08e4a7a5afd9e3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a020d6ddc895150cbf08e4a7a5afd9e3f">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a020d6ddc895150cbf08e4a7a5afd9e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces the given element at the beginning of the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a020d6ddc895150cbf08e4a7a5afd9e3f">More...</a><br /></td></tr>
<tr class="separator:a020d6ddc895150cbf08e4a7a5afd9e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b90625421a518a5a7d3d036fdee9912"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7b90625421a518a5a7d3d036fdee9912">erase</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a7b90625421a518a5a7d3d036fdee9912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at 'pos'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7b90625421a518a5a7d3d036fdee9912">More...</a><br /></td></tr>
<tr class="separator:a7b90625421a518a5a7d3d036fdee9912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251bd9789ce15a13e967e1d4921d60b7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a251bd9789ce15a13e967e1d4921d60b7">erase_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a251bd9789ce15a13e967e1d4921d60b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at 'pos'. <br  />
 Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are shifted to occupy the erased space.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a251bd9789ce15a13e967e1d4921d60b7">More...</a><br /></td></tr>
<tr class="separator:a251bd9789ce15a13e967e1d4921d60b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e8d5b176d1e2bb852bc8b3f853b036"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae0e8d5b176d1e2bb852bc8b3f853b036">erase_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ae0e8d5b176d1e2bb852bc8b3f853b036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at 'pos'. <br  />
 Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are shifted to occupy the erased space.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae0e8d5b176d1e2bb852bc8b3f853b036">More...</a><br /></td></tr>
<tr class="separator:ae0e8d5b176d1e2bb852bc8b3f853b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15a51cef99039187dfdfcade177dc93"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa15a51cef99039187dfdfcade177dc93">erase</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> start, <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> stop)</td></tr>
<tr class="memdesc:aa15a51cef99039187dfdfcade177dc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa15a51cef99039187dfdfcade177dc93">More...</a><br /></td></tr>
<tr class="separator:aa15a51cef99039187dfdfcade177dc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb82d9b4b37ff4c216c6deb6b81e65f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7fb82d9b4b37ff4c216c6deb6b81e65f">erase_move_back</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> start, <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> stop)</td></tr>
<tr class="memdesc:a7fb82d9b4b37ff4c216c6deb6b81e65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last). Elements in the range [last, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are shifted to occupy the erased space.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7fb82d9b4b37ff4c216c6deb6b81e65f">More...</a><br /></td></tr>
<tr class="separator:a7fb82d9b4b37ff4c216c6deb6b81e65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd371976bc41c466b1a3b57265e64972"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#abd371976bc41c466b1a3b57265e64972">erase_move_front</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> start, <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> stop)</td></tr>
<tr class="memdesc:abd371976bc41c466b1a3b57265e64972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last). Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are shifted to occupy the erased space.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#abd371976bc41c466b1a3b57265e64972">More...</a><br /></td></tr>
<tr class="separator:abd371976bc41c466b1a3b57265e64972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12db0aca9cd96111b7dd02084511493"><td class="memTemplParams" colspan="2">template&lt;class Pred &gt; </td></tr>
<tr class="memitem:af12db0aca9cd96111b7dd02084511493"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af12db0aca9cd96111b7dd02084511493">erase_if</a> (Pred pred)</td></tr>
<tr class="memdesc:af12db0aca9cd96111b7dd02084511493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements for which 'pred' returns true.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af12db0aca9cd96111b7dd02084511493">More...</a><br /></td></tr>
<tr class="separator:af12db0aca9cd96111b7dd02084511493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d9c5a3e6fa982708949f4a45707a0d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a09d9c5a3e6fa982708949f4a45707a0d">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a09d9c5a3e6fa982708949f4a45707a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container. The new element is initialized as a copy of value.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a09d9c5a3e6fa982708949f4a45707a0d">More...</a><br /></td></tr>
<tr class="separator:a09d9c5a3e6fa982708949f4a45707a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56dd91bff47e86af06f860a8a5868aa"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ac56dd91bff47e86af06f860a8a5868aa">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ac56dd91bff47e86af06f860a8a5868aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container. 'value' is moved into the new element.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ac56dd91bff47e86af06f860a8a5868aa">More...</a><br /></td></tr>
<tr class="separator:ac56dd91bff47e86af06f860a8a5868aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4934f16484eeadcff4d63d3086905027"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4934f16484eeadcff4d63d3086905027">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4934f16484eeadcff4d63d3086905027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the container. The new element is initialized as a copy of value.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4934f16484eeadcff4d63d3086905027">More...</a><br /></td></tr>
<tr class="separator:a4934f16484eeadcff4d63d3086905027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e3a08d5a768d4c27f46963a4e88548"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a05e3a08d5a768d4c27f46963a4e88548">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a05e3a08d5a768d4c27f46963a4e88548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the container. The new element is initialized as a copy of value.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a05e3a08d5a768d4c27f46963a4e88548">More...</a><br /></td></tr>
<tr class="separator:a05e3a08d5a768d4c27f46963a4e88548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992e6a6494bbdfd0af7e4033aeb863d2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a992e6a6494bbdfd0af7e4033aeb863d2">pop_back</a> ()</td></tr>
<tr class="memdesc:a992e6a6494bbdfd0af7e4033aeb863d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a992e6a6494bbdfd0af7e4033aeb863d2">More...</a><br /></td></tr>
<tr class="separator:a992e6a6494bbdfd0af7e4033aeb863d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0481b5fc50b6db0cd72941a5dac0fca"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ad0481b5fc50b6db0cd72941a5dac0fca">pop_back_n</a> (size_type count)</td></tr>
<tr class="memdesc:ad0481b5fc50b6db0cd72941a5dac0fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last 'count' elements from the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ad0481b5fc50b6db0cd72941a5dac0fca">More...</a><br /></td></tr>
<tr class="separator:ad0481b5fc50b6db0cd72941a5dac0fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05a2c822700e5355b7c02ace3764104"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab05a2c822700e5355b7c02ace3764104">pop_front</a> ()</td></tr>
<tr class="memdesc:ab05a2c822700e5355b7c02ace3764104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab05a2c822700e5355b7c02ace3764104">More...</a><br /></td></tr>
<tr class="separator:ab05a2c822700e5355b7c02ace3764104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405d1063b1d6217d3c77e7730b818ff"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa405d1063b1d6217d3c77e7730b818ff">pop_front_n</a> (size_type count)</td></tr>
<tr class="memdesc:aa405d1063b1d6217d3c77e7730b818ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first 'count' elements from the container.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa405d1063b1d6217d3c77e7730b818ff">More...</a><br /></td></tr>
<tr class="separator:aa405d1063b1d6217d3c77e7730b818ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623cd26be0deb9f68676776a97a1ace7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a623cd26be0deb9f68676776a97a1ace7">resize</a> (size_type count)</td></tr>
<tr class="memdesc:a623cd26be0deb9f68676776a97a1ace7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a623cd26be0deb9f68676776a97a1ace7">More...</a><br /></td></tr>
<tr class="separator:a623cd26be0deb9f68676776a97a1ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f3d9785851ff0b16a46e6e44eea286"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a07f3d9785851ff0b16a46e6e44eea286">resize</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a07f3d9785851ff0b16a46e6e44eea286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a07f3d9785851ff0b16a46e6e44eea286">More...</a><br /></td></tr>
<tr class="separator:a07f3d9785851ff0b16a46e6e44eea286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7b67e8ecb8953737473d0d0e6e70ef"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a5b7b67e8ecb8953737473d0d0e6e70ef">resize_front</a> (size_type count)</td></tr>
<tr class="memdesc:a5b7b67e8ecb8953737473d0d0e6e70ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a5b7b67e8ecb8953737473d0d0e6e70ef">More...</a><br /></td></tr>
<tr class="separator:a5b7b67e8ecb8953737473d0d0e6e70ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6216822c8742678e03577149f1dd8dac"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6216822c8742678e03577149f1dd8dac">resize_front</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a6216822c8742678e03577149f1dd8dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6216822c8742678e03577149f1dd8dac">More...</a><br /></td></tr>
<tr class="separator:a6216822c8742678e03577149f1dd8dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7fc97b13a3863be61bbff04aa1f76fbf">append</a> (It first, It last)</td></tr>
<tr class="memdesc:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements in the range [first, last) to the end of the container, as if by calling 'v.insert(v.end(), first, last)'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7fc97b13a3863be61bbff04aa1f76fbf">More...</a><br /></td></tr>
<tr class="separator:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7fc97b13a3863be61bbff04aa1f76fbf">append</a> (It first, It last)</td></tr>
<tr class="memdesc:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements in the range [first, last) to the end of the container, as if by calling 'insert(end(), first, last)'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7fc97b13a3863be61bbff04aa1f76fbf">More...</a><br /></td></tr>
<tr class="separator:a7fc97b13a3863be61bbff04aa1f76fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1dd9191e8b942a65b24b4465db50fc"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a4f1dd9191e8b942a65b24b4465db50fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4f1dd9191e8b942a65b24b4465db50fc">prepend</a> (It first, It last)</td></tr>
<tr class="memdesc:a4f1dd9191e8b942a65b24b4465db50fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements in the range [first, last) to the beginning of the container, as if by calling 'insert(begin(), first, last)'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4f1dd9191e8b942a65b24b4465db50fc">More...</a><br /></td></tr>
<tr class="separator:a4f1dd9191e8b942a65b24b4465db50fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1dd9191e8b942a65b24b4465db50fc"><td class="memTemplParams" colspan="2">template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </td></tr>
<tr class="memitem:a4f1dd9191e8b942a65b24b4465db50fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4f1dd9191e8b942a65b24b4465db50fc">prepend</a> (It first, It last)</td></tr>
<tr class="memdesc:a4f1dd9191e8b942a65b24b4465db50fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements in the range [first, last) to the beginning of the container, as if by calling 'insert(begin(), first, last)'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4f1dd9191e8b942a65b24b4465db50fc">More...</a><br /></td></tr>
<tr class="separator:a4f1dd9191e8b942a65b24b4465db50fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fd24b0fe7df00f7a3aba6b77bfe30c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae5fd24b0fe7df00f7a3aba6b77bfe30c">shift_right</a> (size_type count)</td></tr>
<tr class="memdesc:ae5fd24b0fe7df00f7a3aba6b77bfe30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the underlying storage such that the starting index of the buffer is shifted right by 'count', without changing the order of the elements in the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae5fd24b0fe7df00f7a3aba6b77bfe30c">More...</a><br /></td></tr>
<tr class="separator:ae5fd24b0fe7df00f7a3aba6b77bfe30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b622b7abb5c7a99943cc0709de5019e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7b622b7abb5c7a99943cc0709de5019e">shift_left</a> (size_type count)</td></tr>
<tr class="memdesc:a7b622b7abb5c7a99943cc0709de5019e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the underlying storage such that the starting index of the buffer is shifted left by 'count', without changing the order of the elements in the buffer.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a7b622b7abb5c7a99943cc0709de5019e">More...</a><br /></td></tr>
<tr class="separator:a7b622b7abb5c7a99943cc0709de5019e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae252dcacf1c2792e59bc2ecfa200bc"><td class="memItemLeft" align="right" valign="top"><a id="a5ae252dcacf1c2792e59bc2ecfa200bc" name="a5ae252dcacf1c2792e59bc2ecfa200bc"></a>
constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_buffer_shape.html">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_shape</b> () const</td></tr>
<tr class="memdesc:a5ae252dcacf1c2792e59bc2ecfa200bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>shape_type</code> describing the layout of the buffer. <br /></td></tr>
<tr class="separator:a5ae252dcacf1c2792e59bc2ecfa200bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3dc4f2240d1567f88489329a230e40"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6b3dc4f2240d1567f88489329a230e40">swap</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;other) noexcept(propagate_on_container_swap||is_always_equal)</td></tr>
<tr class="memdesc:a6b3dc4f2240d1567f88489329a230e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a6b3dc4f2240d1567f88489329a230e40">More...</a><br /></td></tr>
<tr class="separator:a6b3dc4f2240d1567f88489329a230e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae75cd5c74b3fa490a26b24da745cd7ff"><td class="memItemLeft" align="right" valign="top">constexpr friend void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae75cd5c74b3fa490a26b24da745cd7ff">swap</a> (<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;l, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;r) noexcept(propagate_on_container_swap||is_always_equal)</td></tr>
<tr class="memdesc:ae75cd5c74b3fa490a26b24da745cd7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of 'l' with those of 'r'.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae75cd5c74b3fa490a26b24da745cd7ff">More...</a><br /></td></tr>
<tr class="separator:ae75cd5c74b3fa490a26b24da745cd7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f698605dcb25a6ff4ee76536c74bc"><td class="memItemLeft" align="right" valign="top">constexpr friend bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a864f698605dcb25a6ff4ee76536c74bc">operator==</a> (const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;l, const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;r)</td></tr>
<tr class="memdesc:a864f698605dcb25a6ff4ee76536c74bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a864f698605dcb25a6ff4ee76536c74bc">More...</a><br /></td></tr>
<tr class="separator:a864f698605dcb25a6ff4ee76536c74bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b6b7343999e91035028b09e5db5b61"><td class="memItemLeft" align="right" valign="top">constexpr friend bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a55b6b7343999e91035028b09e5db5b61">operator!=</a> (const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;l, const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp;r)=default</td></tr>
<tr class="memdesc:a55b6b7343999e91035028b09e5db5b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are not equal, that is, they have a different number of elements or if any element in lhs compares not equal with the element in rhs at the same position.  <a href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a55b6b7343999e91035028b09e5db5b61">More...</a><br /></td></tr>
<tr class="separator:a55b6b7343999e91035028b09e5db5b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Allocator&gt;<br />
struct tim::circular_buffer::CircularBuffer&lt; T, Allocator &gt;</div><p >A sequence container that encapsulates a resizable ring/circular buffer. </p>
<p >This type is similar to std::vector, supporting nearly every member function that std::vector has (with near identical semantics), except that the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a> supports additional operations and does not guarantee that its elements are stored contiguously.</p>
<p >The elements are stored in a contiguous underlying "physical" buffer but instead of storage always beginning at the start of the "physical" buffer, as is done with std::vector, instead the actual "logical" position of the beginning of the element storage may be at some offset into the physical buffer. Additionally, the "logical" end of the element storage may wrap around to the beginning of the "physical" buffer if the needed. This flexibility in the start and end of the buffer allows for elements to be more efficiently moved around in storage when performing certain operations. For example inserting elements near the front of a std::vector's storage, say at index 2, would require moving all elements after <br  />
 index 2, whereas with <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a>, only those 2 elements preceding the element at index 2 would need to be moved to make room for the insertion (assuming no reallocation takes place). This flexibility also allows for more efficient implementations of other operations, such as erasure (including a faster '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af12db0aca9cd96111b7dd02084511493" title="Erases all elements for which &#39;pred&#39; returns true.">erase_if()</a>'), prepending elements, condition. This efficiency comes at the price of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a> being larger than an efficiently-implemented std::vector by additional pointer-sized member, as well as slightly more costly traversal of the stored elements (e.g. "fat" iterators that are about the size of 3 pointers).</p>
<p ><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a> efficiently support additional operations that std::vector does not, such as <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4934f16484eeadcff4d63d3086905027" title="Prepends the given element value to the beginning of the container. The new element is initialized as...">push_front()</a>/pop_front(), and "shifting" of logical elements' positions in the physical storage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements. </td></tr>
    <tr><td class="paramname">Allocator</td><td>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of Allocator. The program is ill-formed (since C++20) if Allocator::value_type is not the same as T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. </dd>
<dd>
<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a> is an <a href="https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer">AllocatorAwareContainer</a>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ebc26b39cb195efaf8fb69d5116bd0d" name="a3ebc26b39cb195efaf8fb69d5116bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc26b39cb195efaf8fb69d5116bd0d">&#9670;&nbsp;</a></span>~CircularBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::~<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroys all elements in the container and releases all memory allocated. </p>

</div>
</div>
<a id="a716159cc439fe225735d3788537b7d02" name="a716159cc439fe225735d3788537b7d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716159cc439fe225735d3788537b7d02">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">al</td><td>The allocator to construct the new buffer with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aead26539d3b7709dd37ea09b749a696c" name="aead26539d3b7709dd37ea09b749a696c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead26539d3b7709dd37ea09b749a696c">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">TagType&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a copy of 'other' with the given allocator 'al' using the method specified by 'tag'. </p>
<p >If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' and '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>' as the old buffer. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' as the old buffer, with unspecified '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>'. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a>', then new buffer will reserve an implementation-defined amount of memory. In practice, this is only enough memory to fit the elements in 'other'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Tag object controlling how the copy operation is to take place; one of tags::optimized, tags::preserve_layout, or tags::preserve_capacity. </td></tr>
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be copied. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to construct the new buffer with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a087d8fc24acb3f458c2718c40b721241" name="a087d8fc24acb3f458c2718c40b721241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087d8fc24acb3f458c2718c40b721241">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt; &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">TagType&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a copy of 'other' using the method specified by 'tag'. </p>
<p >If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' and '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>' as the old buffer. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' as the old buffer, with unspecified '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>'. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a>', then new buffer will reserve only enough memory to fit the elements in 'other'.</p>
<p >The allocator of the new buffer is determined as if by calling 'other.get_allocator().select_on_container_copy_construction()'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Tag object controlling how the copy operation is to take place; one of tags::optimized, tags::preserve_layout, or tags::preserve_capacity. </td></tr>
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ebc01c465e2b01e53816fbf42ac96b" name="a91ebc01c465e2b01e53816fbf42ac96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ebc01c465e2b01e53816fbf42ac96b">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a copy of 'other' with the given allocator 'al' as if by calling 'CircularBuffer(tags::optimized, other, al)'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Tag object controlling how the copy operation is to take place; one of tags::optimized, tags::preserve_layout, or tags::preserve_capacity. </td></tr>
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f9c04f77060be59d9349d6ada607494" name="a0f9c04f77060be59d9349d6ada607494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9c04f77060be59d9349d6ada607494">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p >Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. After the move, other is guaranteed to be <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a593db6d133f6f2e7802666c55ca73cd4" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7a1dc7b8c5e6ff11c42d71e0ef803be" name="aa7a1dc7b8c5e6ff11c42d71e0ef803be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a1dc7b8c5e6ff11c42d71e0ef803be">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt; &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">TagType&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tagged move constructor. </p>
<p >Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. After the move, other is guaranteed to be <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a593db6d133f6f2e7802666c55ca73cd4" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. Move-constructs a copy of 'other' using the method specified by 'tag'. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' and '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>' as the old buffer. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' as the old buffer, with unspecified '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>'. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a>', then new buffer will reserve only enough memory to fit the elements in 'other'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Tag object controlling how the copy operation is to take place; one of tags::optimized, tags::preserve_layout, or tags::preserve_capacity. </td></tr>
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In practice, the 'tag' argument is ignored as the 'optimized' path is the same as the layout-preserving path and no memory is allocated. </dd>
<dd>
This overload exists primarily to support perfect-forwarding in conjunction with the non-moving version. </dd></dl>

</div>
</div>
<a id="a5b6928dc88f1bdb9799ae55d459724de" name="a5b6928dc88f1bdb9799ae55d459724de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6928dc88f1bdb9799ae55d459724de">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class TagType , std::enable_if_t&lt; detail::is_one_of_v&lt; TagType, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>, <a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a> &gt; &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">TagType&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tagged move constructor with custom allocator. </p>
<p >Constructs the container with the contents of other using move semantics. Allocator is obtained from the parameter 'al'. After the move, other is guaranteed to be <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a593db6d133f6f2e7802666c55ca73cd4" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. Move-constructs a copy of 'other' using the method specified by 'tag'. If the passed-in allocator is equal to the allocator used by 'other' (determined by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a864f698605dcb25a6ff4ee76536c74bc" title="Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and e...">operator==()</a> or if std::allocator_traits&lt;Allocator&gt;::is_always_equal is true), then this overload proceeds similarly to '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#aa7a1dc7b8c5e6ff11c42d71e0ef803be" title="Tagged move constructor.">CircularBuffer(TagType tag, CircularBuffer&amp;&amp; other)</a>'. That is, no new memory is allocated and instead the new buffer takes ownership of the memory from 'other'. Otherwise, if the allocators are not equal, then 'al' is used to initialize the new buffer's allocator, and the elements from 'other' are moved into the new storage. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_layout.html">tags::PreserveBufferLayout</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' and '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>' as the old buffer. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_preserve_buffer_capacity.html">tags::PreserveBufferCapacity</a>', then new buffer will have the same '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' as the old buffer, with unspecified '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>'. If 'tag' has type '<a class="el" href="structtim_1_1circular__buffer_1_1tags_1_1_optimized.html">tags::Optimized</a>', then new buffer will reserve only enough memory to fit the elements in 'other'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Tag object controlling how the copy operation is to take place; one of tags::optimized, tags::preserve_layout, or tags::preserve_capacity. </td></tr>
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be moved. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13d1d7b1652c49185582cff027fae86c" name="a13d1d7b1652c49185582cff027fae86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d1d7b1652c49185582cff027fae86c">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with custom allocator. </p>
<p >Constructs the container with the contents of other using move semantics. Allocator is obtained from the parameter 'al'. After the move, other is guaranteed to be <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a593db6d133f6f2e7802666c55ca73cd4" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. If the passed-in allocator is equal to the allocator used by 'other' (determined by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a864f698605dcb25a6ff4ee76536c74bc" title="Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and e...">operator==()</a> or if std::allocator_traits&lt;Allocator&gt;::is_always_equal is true), then this overload proceeds similarly to '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a0f9c04f77060be59d9349d6ada607494" title="Move constructor.">CircularBuffer(CircularBuffer&amp;&amp; other)</a>'. That is, no new memory is allocated and instead the new buffer takes ownership of the memory from 'other'. Otherwise, if the allocators are not equal, then 'al' is used to initialize the new buffer's allocator, and the elements from 'other' are moved into the new storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The circular buffer whose contents are to be moved. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d973d0eb58173f340936786eef6203b" name="a8d973d0eb58173f340936786eef6203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d973d0eb58173f340936786eef6203b">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_buffer_shape.html">shape_type</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shape constructor. </p>
<p >Constructs an empty buffer with a predefined '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>' and '<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape object definining the initial layout of the new buffer. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a371706b742bd94bd4d4715a7699b001d" name="a371706b742bd94bd4d4715a7699b001d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371706b742bd94bd4d4715a7699b001d">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list constructor. </p>
<p >Constructs the container with the contents of the initializer list 'init'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initializer list whose contents are used to initialize the buffer. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cfe3245c3c3ff1b9d2bb9007e777e2f" name="a0cfe3245c3c3ff1b9d2bb9007e777e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfe3245c3c3ff1b9d2bb9007e777e2f">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with 'count' copies of elements with value 'value'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements to construct. </td></tr>
    <tr><td class="paramname">value</td><td>The object whose value is used to initialize the new elements. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac89bbdeb4cce4f0991fc8ba5308cef84" name="ac89bbdeb4cce4f0991fc8ba5308cef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89bbdeb4cce4f0991fc8ba5308cef84">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with 'count' default-consrtucted elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements to construct. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9e3c6b822cedd481315cc2bf05c8fcf" name="af9e3c6b822cedd481315cc2bf05c8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3c6b822cedd481315cc2bf05c8fcf">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the range to construct the buffer from. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the past-the-end element in the range to construct the buffer from. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9e3c6b822cedd481315cc2bf05c8fcf" name="af9e3c6b822cedd481315cc2bf05c8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3c6b822cedd481315cc2bf05c8fcf">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_same_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the range to construct the buffer from. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the past-the-end element in the range to construct the buffer from. </td></tr>
    <tr><td class="paramname">al</td><td>The allocator to use for the new buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade61eb49494a69ddad1588b8d7eab3fb" name="ade61eb49494a69ddad1588b8d7eab3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade61eb49494a69ddad1588b8d7eab3fb">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a> whose contents are to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The copy constructor does not necessarily preserve the layout or capacity of the 'other'. If you require this behavior, consider using the tagged copy constructor. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fc97b13a3863be61bbff04aa1f76fbf" name="a7fc97b13a3863be61bbff04aa1f76fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc97b13a3863be61bbff04aa1f76fbf">&#9670;&nbsp;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::append </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds elements in the range [first, last) to the end of the container, as if by calling 'v.insert(v.end(), first, last)'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the range of values to append. </td></tr>
    <tr><td class="paramname">last</td><td>The past-the-end iterator for the range of values to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an exception is thrown while copying elements in the range [first, last) to their destination location in the container, there are no effects. </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the throwing move constructor will be used. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

</div>
</div>
<a id="a7fc97b13a3863be61bbff04aa1f76fbf" name="a7fc97b13a3863be61bbff04aa1f76fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc97b13a3863be61bbff04aa1f76fbf">&#9670;&nbsp;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::append </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds elements in the range [first, last) to the end of the container, as if by calling 'insert(end(), first, last)'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the range of values to append. </td></tr>
    <tr><td class="paramname">last</td><td>The past-the-end iterator for the range of values to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an exception is thrown while copying elements in the range [first, last) to their destination location in the container, there are no effects. </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the throwing move constructor will be used. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

</div>
</div>
<a id="ad7ebc7d868951bdd2da6ddd8561fd680" name="ad7ebc7d868951bdd2da6ddd8561fd680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ebc7d868951bdd2da6ddd8561fd680">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first value in the range of elements to be copied. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to one past the last value in the range of elements to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if either argument is an iterator into *this. </dd></dl>

</div>
</div>
<a id="a054a8609d45d2f1bbc04b4cb6e73b4ba" name="a054a8609d45d2f1bbc04b4cb6e73b4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054a8609d45d2f1bbc04b4cb6e73b4ba">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements to assign. </td></tr>
    <tr><td class="paramname">value</td><td>The object to copy-initialize the new elements from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab14cb989d7b779dee25738111131dc17" name="ab14cb989d7b779dee25738111131dc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14cb989d7b779dee25738111131dc17">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list 'init'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initializer list whose contents are used to assign the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37eae3a0874d1754fa34391de19b488a" name="a37eae3a0874d1754fa34391de19b488a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eae3a0874d1754fa34391de19b488a">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the element at specified location 'index', with bounds checking. </p>
<p >If 'index' is not within the range of the container, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index into the logical buffer of the element to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a319a56d9d22a6a3fe41dbfd85d0764c3" name="a319a56d9d22a6a3fe41dbfd85d0764c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319a56d9d22a6a3fe41dbfd85d0764c3">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the element at specified location 'index', with bounds checking. </p>
<p >If 'index' is not within the range of the container, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index into the logical buffer of the element to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae700a11c77bd8c6e93568991dc831c04" name="ae700a11c77bd8c6e93568991dc831c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae700a11c77bd8c6e93568991dc831c04">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the last element in the container. </p>
<p >Calling back on an empty container is undefined. </p>

</div>
</div>
<a id="a76a8a8894dba794ac119074fcbb95176" name="a76a8a8894dba794ac119074fcbb95176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a8a8894dba794ac119074fcbb95176">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the last element in the container. </p>
<p >Calling back on an empty container is undefined. </p>

</div>
</div>
<a id="a09c8b9cb4194d6e6dc1fceb1ba0bd777" name="a09c8b9cb4194d6e6dc1fceb1ba0bd777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c8b9cb4194d6e6dc1fceb1ba0bd777">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the element following the last element of the buffer. </p>
<p >This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="af8ef9ed422e6a6d76b6f2ed964ca42de" name="af8ef9ed422e6a6d76b6f2ed964ca42de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef9ed422e6a6d76b6f2ed964ca42de">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. </p>
<p >After this call, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated. <br  />
 Leaves the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> of the buffer unchanged. </p>

</div>
</div>
<a id="a93223c4facf17c266e3ce129eab85d14" name="a93223c4facf17c266e3ce129eab85d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93223c4facf17c266e3ce129eab85d14">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reverse_iterator <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the first element of the reversed buffer. </p>
<p >It corresponds to the last element of the non-reversed buffer. If the buffer is empty, the returned iterator is equal to <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1a2c780d821edaf9e0c28f10d85ef3df" title="Returns a mutable reverse iterator to the element following the last element of the reversed buffer.">rend()</a>. </p>

</div>
</div>
<a id="af527dd6cb3b04c89e06a08bbd82976c7" name="af527dd6cb3b04c89e06a08bbd82976c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af527dd6cb3b04c89e06a08bbd82976c7">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reverse_iterator <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element following the last element of the reversed buffer. </p>
<p >It corresponds to the element preceding the first element of the non-reversed buffer. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="ab23c504881658420baa02968e1b18582" name="ab23c504881658420baa02968e1b18582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23c504881658420baa02968e1b18582">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces the given element before pos. </p>
<p >If the number of elements before pos is less than the number of elements after pos, then the new value is emplaced as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a29aa5aefe5672916a6ed3f3c92b0216d" title="Emplaces the given element before pos. Elements in the range [begin(), pos) are moved to make room fo...">emplace_move_front()</a>, otherwise they are inserted as if by <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae072c351a8994d40922cef40d08a2216" title="Emplaces the given element before pos. Elements in the range [pos, end()) are moved to make room for ...">emplace_move_back()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments with which the new element is to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. </dd>
<dd>
The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is greater than before the call, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. </dd></dl>

</div>
</div>
<a id="ac1e5cfe043921bd673d283ec0b2ec1fc" name="ac1e5cfe043921bd673d283ec0b2ec1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e5cfe043921bd673d283ec0b2ec1fc">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces the given element at the past-the-end position in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments with which the new element is to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place. </dd>
<dd>
The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. </dd></dl>

</div>
</div>
<a id="a020d6ddc895150cbf08e4a7a5afd9e3f" name="a020d6ddc895150cbf08e4a7a5afd9e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020d6ddc895150cbf08e4a7a5afd9e3f">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces the given element at the beginning of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments with which the new element is to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place. </dd>
<dd>
The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is greater than before the call, all iterators and references are invalidated. </dd></dl>

</div>
</div>
<a id="ae072c351a8994d40922cef40d08a2216" name="ae072c351a8994d40922cef40d08a2216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae072c351a8994d40922cef40d08a2216">&#9670;&nbsp;</a></span>emplace_move_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::emplace_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces the given element before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments with which the new element is to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. </dd>
<dd>
The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. </dd></dl>

</div>
</div>
<a id="a29aa5aefe5672916a6ed3f3c92b0216d" name="a29aa5aefe5672916a6ed3f3c92b0216d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aa5aefe5672916a6ed3f3c92b0216d">&#9670;&nbsp;</a></span>emplace_move_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::emplace_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces the given element before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments with which the new element is to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. However, if the required location has been occupied by an existing element, the inserted element is constructed at another location at first, and then move assigned into the required location. </dd>
<dd>
The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... args... may directly or indirectly refer to a value in the container. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is greater than before the call, all iterators and references are invalidated. Otherwise, only the iterators and references after the insertion point remain valid. </dd></dl>

</div>
</div>
<a id="a593db6d133f6f2e7802666c55ca73cd4" name="a593db6d133f6f2e7802666c55ca73cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593db6d133f6f2e7802666c55ca73cd4">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a> == <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise </dd></dl>

</div>
</div>
<a id="a04836f6e6e58a1fc20d93354b7d5c9d1" name="a04836f6e6e58a1fc20d93354b7d5c9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04836f6e6e58a1fc20d93354b7d5c9d1">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the element following the last element of the buffer. </p>
<p >This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a83aa8f9577ec50396dca0ce8106a335c" name="a83aa8f9577ec50396dca0ce8106a335c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aa8f9577ec50396dca0ce8106a335c">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable iterator to the element following the last element of the buffer. </p>
<p >This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a4264f704119f7fed2b667a67a0521ba0" name="a4264f704119f7fed2b667a67a0521ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4264f704119f7fed2b667a67a0521ba0">&#9670;&nbsp;</a></span>end_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::end_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into the raw memory buffer of the element following the last element in the buffer. </p>
<p >If the buffer is either empty or at capacity, this is equal to <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>. </p>

</div>
</div>
<a id="a7b90625421a518a5a7d3d036fdee9912" name="a7b90625421a518a5a7d3d036fdee9912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b90625421a518a5a7d3d036fdee9912">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at 'pos'. </p>
<p >If std::distance(begin(), pos) &lt; std::distance(pos, end()) then the element is erased as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae0e8d5b176d1e2bb852bc8b3f853b036" title="Removes the element at &#39;pos&#39;.   Elements in the range [begin(), pos) are shifted to occupy the erased...">erase_move_front()</a>, otherwise the erasure proceeds as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a251bd9789ce15a13e967e1d4921d60b7" title="Removes the element at &#39;pos&#39;.   Elements in the range [pos, end()) are shifted to occupy the erased s...">erase_move_back()</a>. If std::distance(begin(), pos) &lt; std::distance(pos, end()), then iterators and references at or before the point of the erasure are invalidated, otherwise iterators and references at or after the point of the erasure are invalidated. Additionally, if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is less than its value before calling the function, then all iterators (but not necessarily references) are invalidated. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the to-be-erased element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa15a51cef99039187dfdfcade177dc93" name="aa15a51cef99039187dfdfcade177dc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15a51cef99039187dfdfcade177dc93">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<p >If std::distance(begin(), first) &lt; std::distance(last, end()) then the element is erased as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae0e8d5b176d1e2bb852bc8b3f853b036" title="Removes the element at &#39;pos&#39;.   Elements in the range [begin(), pos) are shifted to occupy the erased...">erase_move_front()</a>, otherwise the erasure proceeds as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a251bd9789ce15a13e967e1d4921d60b7" title="Removes the element at &#39;pos&#39;.   Elements in the range [pos, end()) are shifted to occupy the erased s...">erase_move_back()</a>. If std::distance(begin(), first) &lt; std::distance(last, end()), then iterators and references at or before the point of the erasure are invalidated, otherwise iterators and references at or after the point of the erasure are invalidated. Additionally, if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is less than its value before calling the function, then all iterators (but not necessarily references) are invalidated. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for 'first' unless 'first == last'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to beginning of the to-be-erased erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element of the to-be-erased erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12db0aca9cd96111b7dd02084511493" name="af12db0aca9cd96111b7dd02084511493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12db0aca9cd96111b7dd02084511493">&#9670;&nbsp;</a></span>erase_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements for which 'pred' returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Predicate function object which returns 'true' for elements that should be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After calling this function, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd>
<dd>
The expression pred(v) must be convertible to bool for every argument v of type (possibly const) T, regardless of value category, and must not modify v. Thus, a parameter type of T&amp; is not allowed, nor is T unless for T a move is equivalent to a copy. </dd></dl>

</div>
</div>
<a id="a251bd9789ce15a13e967e1d4921d60b7" name="a251bd9789ce15a13e967e1d4921d60b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251bd9789ce15a13e967e1d4921d60b7">&#9670;&nbsp;</a></span>erase_move_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at 'pos'. <br  />
 Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are shifted to occupy the erased space. </p>
<p >Iterators and references at or after the point of the erasure are invalidated. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the to-be-erased element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb82d9b4b37ff4c216c6deb6b81e65f" name="a7fb82d9b4b37ff4c216c6deb6b81e65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb82d9b4b37ff4c216c6deb6b81e65f">&#9670;&nbsp;</a></span>erase_move_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). Elements in the range [last, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are shifted to occupy the erased space. </p>
<p >Iterators and references at or after the point of the erasure are invalidated. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for 'first' unless 'first == last'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to beginning of the to-be-erased erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element of the to-be-erased erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0e8d5b176d1e2bb852bc8b3f853b036" name="ae0e8d5b176d1e2bb852bc8b3f853b036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e8d5b176d1e2bb852bc8b3f853b036">&#9670;&nbsp;</a></span>erase_move_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at 'pos'. <br  />
 Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are shifted to occupy the erased space. </p>
<p >Iterators and references at or before the point of the erasure are invalidated. Additionally, if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is less than its value before calling the function, then all iterators (but not necessarily references) are invalidated. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the to-be-erased element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd371976bc41c466b1a3b57265e64972" name="abd371976bc41c466b1a3b57265e64972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd371976bc41c466b1a3b57265e64972">&#9670;&nbsp;</a></span>erase_move_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::erase_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are shifted to occupy the erased space. </p>
<p >If std::distance(begin(), first) &lt; std::distance(last, end()) then the element is erased as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ae0e8d5b176d1e2bb852bc8b3f853b036" title="Removes the element at &#39;pos&#39;.   Elements in the range [begin(), pos) are shifted to occupy the erased...">erase_move_front()</a>, otherwise the erasure proceeds as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a251bd9789ce15a13e967e1d4921d60b7" title="Removes the element at &#39;pos&#39;.   Elements in the range [pos, end()) are shifted to occupy the erased s...">erase_move_back()</a>. If std::distance(begin(), first) &lt; std::distance(last, end()), then iterators and references at or before the point of the erasure are invalidated, otherwise iterators and references at or after the point of the erasure are invalidated. Additionally, if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> after calling this function is less than its value before calling the function, then all iterators (but not necessarily references) are invalidated. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for 'first' unless 'first == last'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to beginning of the to-be-erased erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element of the to-be-erased erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ebefe9e20033161bc1f88182ec58b03" name="a1ebefe9e20033161bc1f88182ec58b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebefe9e20033161bc1f88182ec58b03">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the first element in the container. </p>
<p >Calling front on an empty container is undefined. </p>

</div>
</div>
<a id="a89d050f0ec9d0b3d8afe1e8d6dcfcdab" name="a89d050f0ec9d0b3d8afe1e8d6dcfcdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d050f0ec9d0b3d8afe1e8d6dcfcdab">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the first element in the container. </p>
<p >Calling front on an empty container is undefined. </p>

</div>
</div>
<a id="aa4911308699818bf18dcf6be161d8e2c" name="aa4911308699818bf18dcf6be161d8e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4911308699818bf18dcf6be161d8e2c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. </p>
<p >If the number of elements before pos is less than the number of elements after pos, then the new values are inserted as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb" title="Inserts elements from range [first, last) before pos. Elements in the range [begin(),...">insert_move_front()</a>, otherwise they are inserted as if by <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5" title="Inserts elements from range [first, last) before pos. Elements in the range [pos, end()) are moved to...">insert_move_back()</a>.</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyInputIterator. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first value in the range of elements to be inserted. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to one past the last value in the range of elements to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d88c759ae26aedd69c15c4953872e7d" name="a6d88c759ae26aedd69c15c4953872e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d88c759ae26aedd69c15c4953872e7d">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts 'count' copies of the given element before pos. </p>
<p >If the number of elements before pos is less than the number of elements after pos, then the new values are inserted as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb" title="Inserts elements from range [first, last) before pos. Elements in the range [begin(),...">insert_move_front()</a>, otherwise they are inserted as if by <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5" title="Inserts elements from range [first, last) before pos. Elements in the range [pos, end()) are moved to...">insert_move_back()</a>.</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyInputIterator. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the inserted elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8701529f819f64fb3128922db5b0c9da" name="a8701529f819f64fb3128922db5b0c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8701529f819f64fb3128922db5b0c9da">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the elements from the initialize list before pos. </p>
<p >If the number of elements before pos is less than the number of elements after pos, then the new values are inserted as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb" title="Inserts elements from range [first, last) before pos. Elements in the range [begin(),...">insert_move_front()</a>, otherwise they are inserted as if by <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5" title="Inserts elements from range [first, last) before pos. Elements in the range [pos, end()) are moved to...">insert_move_back()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">ilist</td><td>initializer list containing the elements to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a565f99e98cf0e5c3903bc3fdba4d2d2a" name="a565f99e98cf0e5c3903bc3fdba4d2d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565f99e98cf0e5c3903bc3fdba4d2d2a">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U , std::enable_if_t&lt; std::is_same_v&lt; T, std::remove_cvref_t&lt; U &gt; &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element before pos. </p>
<p >If the number of elements before pos is less than the number of elements after pos, then the new value is inserted as if by calling <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a245dd4f06dc1ef6bdffc56481e7915bb" title="Inserts elements from range [first, last) before pos. Elements in the range [begin(),...">insert_move_front()</a>, otherwise they are inserted as if by <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a8d2973ef10e5a2738f7a915785427ca5" title="Inserts elements from range [first, last) before pos. Elements in the range [pos, end()) are moved to...">insert_move_back()</a>.</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyInputIterator. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d2973ef10e5a2738f7a915785427ca5" name="a8d2973ef10e5a2738f7a915785427ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2973ef10e5a2738f7a915785427ca5">&#9670;&nbsp;</a></span>insert_move_back() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> will change accordingly (but <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will be unchanged).</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyInputIterator, but not LegacyForwardIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first value in the range of elements to be inserted. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to one past the last value in the range of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a8d2973ef10e5a2738f7a915785427ca5" name="a8d2973ef10e5a2738f7a915785427ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2973ef10e5a2738f7a915785427ca5">&#9670;&nbsp;</a></span>insert_move_back() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> will change accordingly (but <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will be unchanged).</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyForwardIterator. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first value in the range of elements to be inserted. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to one past the last value in the range of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a26ef209df4db1de90a16d8fc51e06b80" name="a26ef209df4db1de90a16d8fc51e06b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ef209df4db1de90a16d8fc51e06b80">&#9670;&nbsp;</a></span>insert_move_back() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts 'count' copies of the given element before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> will change accordingly (but <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will be unchanged).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the inserted elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="ae6b6772a6b403a42c74b496edbe4b3c3" name="ae6b6772a6b403a42c74b496edbe4b3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b6772a6b403a42c74b496edbe4b3c3">&#9670;&nbsp;</a></span>insert_move_back() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the elements from the initialize list before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> will change accordingly (but <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will be unchanged).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">ilist</td><td>Initializer list containing the elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a6a741c8e1f5921a635a2799749f3267a" name="a6a741c8e1f5921a635a2799749f3267a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a741c8e1f5921a635a2799749f3267a">&#9670;&nbsp;</a></span>insert_move_back() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U , std::enable_if_t&lt; std::is_same_v&lt; T, std::remove_cvref_t&lt; U &gt; &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element before pos. Elements in the range [pos, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> will change accordingly (but <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will be unchanged).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a245dd4f06dc1ef6bdffc56481e7915bb" name="a245dd4f06dc1ef6bdffc56481e7915bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245dd4f06dc1ef6bdffc56481e7915bb">&#9670;&nbsp;</a></span>insert_move_front() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will change accordingly (but <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> will be unchanged).</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyInputIterator, but not LegacyForwardIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first value in the range of elements to be inserted. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to one past the last value in the range of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a245dd4f06dc1ef6bdffc56481e7915bb" name="a245dd4f06dc1ef6bdffc56481e7915bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245dd4f06dc1ef6bdffc56481e7915bb">&#9670;&nbsp;</a></span>insert_move_front() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will change accordingly.</p>
<p >This overload only participates in overload resolution if InputIt qualifies as LegacyForwardIterator. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first value in the range of elements to be inserted. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to one past the last value in the range of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="af1c3138d29b59cc28c524854502292be" name="af1c3138d29b59cc28c524854502292be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c3138d29b59cc28c524854502292be">&#9670;&nbsp;</a></span>insert_move_front() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts 'count' copies of the given element before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will change accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the inserted elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a077e56576efcc2a54a282d983292a7e5" name="a077e56576efcc2a54a282d983292a7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077e56576efcc2a54a282d983292a7e5">&#9670;&nbsp;</a></span>insert_move_front() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the elements from the initialize list before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted range. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will change accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">ilist</td><td>Initializer list containing the elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="a743b3fa8cfee1b831ffd8ce783f87a95" name="a743b3fa8cfee1b831ffd8ce783f87a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743b3fa8cfee1b831ffd8ce783f87a95">&#9670;&nbsp;</a></span>insert_move_front() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class U , std::enable_if_t&lt; std::is_same_v&lt; T, std::remove_cvref_t&lt; U &gt; &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer_iterator.html">iterator</a> <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::insert_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_const_circular_buffer_iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element before pos. Elements in the range [<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, pos) are moved to make room for the to-be-inserted ivalue. </p>
<p >Note that this means the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> will change accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If reallocation occurs, the values of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> and <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4264f704119f7fed2b667a67a0521ba0" title="Returns the index into the raw memory buffer of the element following the last element in the buffer.">end_index()</a> are unspecified. </dd></dl>

</div>
</div>
<a id="ab9908fd82e8fb9d15b5a8b7eceb73251" name="ab9908fd82e8fb9d15b5a8b7eceb73251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9908fd82e8fb9d15b5a8b7eceb73251">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a77d2c872d6ed5746772b8b60890ee8b4" title="Returns a mutable iterator to the first element of the buffer.">begin()</a>, <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a>) for the largest possible container. </p>
<dl class="section note"><dt>Note</dt><dd>This value typically reflects the theoretical limit on the size of the container, at most std::numeric_limits&lt;difference_type&gt;::max(). </dd>
<dd>
At runtime, the size of the container may be limited to a value smaller than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#ab9908fd82e8fb9d15b5a8b7eceb73251" title="Returns the maximum number of elements the container is able to hold due to system or library impleme...">max_size()</a> by the amount of RAM available. </dd></dl>

</div>
</div>
<a id="a2234113f2698a042e0bc1c2956dabc22" name="a2234113f2698a042e0bc1c2956dabc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2234113f2698a042e0bc1c2956dabc22">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp; <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad267b455d6727bcb19549c7f05906866" name="ad267b455d6727bcb19549c7f05906866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad267b455d6727bcb19549c7f05906866">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp; <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html" title="A sequence container that encapsulates a resizable ring/circular buffer.">CircularBuffer</a> whose contents are to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value is true, the allocator of *this is replaced by a copy of that of other. If the allocator of *this after assignment would compare unequal to its old value, the old allocator is used to deallocate the memory, then the new allocator is used to allocate it before copying the elements. Otherwise, the memory owned by *this may be reused when possible. In any case, the elements originally belong to *this may be either destroyed or replaced by element-wise copy-assignment. </dd></dl>

</div>
</div>
<a id="abc292efb7a4493b4f69a399460004bac" name="abc292efb7a4493b4f69a399460004bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc292efb7a4493b4f69a399460004bac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a> &amp; <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list 'init'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initializer list whose contents are used to initialize the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f5a3c654732cbb5d8090a7d26d9243d" name="a3f5a3c654732cbb5d8090a7d26d9243d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5a3c654732cbb5d8090a7d26d9243d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the element at specified location 'index'. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index into the logical buffer of the element to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dfe5d082fad35322c9be31665a164f4" name="a6dfe5d082fad35322c9be31665a164f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe5d082fad35322c9be31665a164f4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the element at specified location 'index'. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index into the logical buffer of the element to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992e6a6494bbdfd0af7e4033aeb863d2" name="a992e6a6494bbdfd0af7e4033aeb863d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992e6a6494bbdfd0af7e4033aeb863d2">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<p >Calling pop_back on an empty container results in undefined behavior. Iterators and references to the last element, as well as the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator, are invalidated. </p>

</div>
</div>
<a id="ad0481b5fc50b6db0cd72941a5dac0fca" name="ad0481b5fc50b6db0cd72941a5dac0fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0481b5fc50b6db0cd72941a5dac0fca">&#9670;&nbsp;</a></span>pop_back_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::pop_back_n </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last 'count' elements from the container. </p>
<p >If 'count' is zero then there are no effects. If 'count' is non-zero, then calling pop_back_n on an empty container results in undefined behavior. Additionally, if 'count' is non-zero, iterators and references to the last 'count' elements, as well as the <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a83aa8f9577ec50396dca0ce8106a335c" title="Returns a mutable iterator to the element following the last element of the buffer.">end()</a> iterator, are invalidated. </p>

</div>
</div>
<a id="ab05a2c822700e5355b7c02ace3764104" name="ab05a2c822700e5355b7c02ace3764104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05a2c822700e5355b7c02ace3764104">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element of the container. </p>
<p >Calling pop_front on an empty container results in undefined behavior. If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> is less than its previous value then all iterators and references are invalidated. Otherwise only iterators and references to the first element are invalidated. </p>

</div>
</div>
<a id="aa405d1063b1d6217d3c77e7730b818ff" name="aa405d1063b1d6217d3c77e7730b818ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa405d1063b1d6217d3c77e7730b818ff">&#9670;&nbsp;</a></span>pop_front_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::pop_front_n </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first 'count' elements from the container. </p>
<p >If 'count' is zero then there are no effects. If 'count' is non-zero, then calling pop_front_n on an empty container results in undefined behavior. If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> is less than its previous value then all iterators and references are invalidated. Otherwise only iterators and references to the first 'count' elements are invalidated. </p>

</div>
</div>
<a id="a4f1dd9191e8b942a65b24b4465db50fc" name="a4f1dd9191e8b942a65b24b4465db50fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1dd9191e8b942a65b24b4465db50fc">&#9670;&nbsp;</a></span>prepend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; detail::is_one_of_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::input_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds elements in the range [first, last) to the beginning of the container, as if by calling 'insert(begin(), first, last)'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the range of values to prepend. </td></tr>
    <tr><td class="paramname">last</td><td>The past-the-end iterator for the range of values to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an exception is thrown while copying elements in the range [first, last) to their destination location in the container, there are no effects. </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the throwing move constructor will be used. If it throws, the guarantee is waived and the effects are unspecified. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> is greater than its previous value, then all iterators and references are invalidated. </dd></dl>

</div>
</div>
<a id="a4f1dd9191e8b942a65b24b4465db50fc" name="a4f1dd9191e8b942a65b24b4465db50fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1dd9191e8b942a65b24b4465db50fc">&#9670;&nbsp;</a></span>prepend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class It , std::enable_if_t&lt; std::is_convertible_v&lt; typename std::iterator_traits&lt; It &gt;::iterator_category, std::forward_iterator_tag &gt;, bool &gt;  = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds elements in the range [first, last) to the beginning of the container, as if by calling 'insert(begin(), first, last)'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the range of values to prepend. </td></tr>
    <tr><td class="paramname">last</td><td>The past-the-end iterator for the range of values to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If an exception is thrown while copying elements in the range [first, last) to their destination location in the container, there are no effects. </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the throwing move constructor will be used. If it throws, the guarantee is waived and the effects are unspecified. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> is greater than its previous value, then all iterators and references are invalidated. </dd></dl>

</div>
</div>
<a id="a09d9c5a3e6fa982708949f4a45707a0d" name="a09d9c5a3e6fa982708949f4a45707a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d9c5a3e6fa982708949f4a45707a0d">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. The new element is initialized as a copy of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the element to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of CopyInsertable in order to use overload. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated. </dd></dl>

</div>
</div>
<a id="ac56dd91bff47e86af06f860a8a5868aa" name="ac56dd91bff47e86af06f860a8a5868aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56dd91bff47e86af06f860a8a5868aa">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. 'value' is moved into the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the element to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of MoveInsertable in order to use overload. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated. </dd>
<dd>
If an exception is thrown (which can be due to Allocator::allocate() or element copy/move constructor/assignment), this function has no effect (strong exception guarantee). </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the implementation will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

</div>
</div>
<a id="a4934f16484eeadcff4d63d3086905027" name="a4934f16484eeadcff4d63d3086905027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4934f16484eeadcff4d63d3086905027">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the container. The new element is initialized as a copy of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the element to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of CopyInsertable in order to use overload. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> is greater than its previous value, then all iterators and references are invalidated. Otherwise no iterators are invalidated. </dd></dl>

</div>
</div>
<a id="a05e3a08d5a768d4c27f46963a4e88548" name="a05e3a08d5a768d4c27f46963a4e88548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e3a08d5a768d4c27f46963a4e88548">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the container. The new element is initialized as a copy of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the element to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of CopyInsertable in order to use overload. </dd>
<dd>
If the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, or if the new <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> is greater than its previous value, then all iterators and references are invalidated. Otherwise no iterators are invalidated. </dd>
<dd>
If an exception is thrown (which can be due to Allocator::allocate() or element copy/move constructor/assignment), this function has no effect (strong exception guarantee). </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the implementation will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

</div>
</div>
<a id="a9bbdeb4add5bed030203676fab6e28ae" name="a9bbdeb4add5bed030203676fab6e28ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbdeb4add5bed030203676fab6e28ae">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reverse_iterator <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the first element of the reversed buffer. </p>
<p >It corresponds to the last element of the non-reversed buffer. If the buffer is empty, the returned iterator is equal to <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1a2c780d821edaf9e0c28f10d85ef3df" title="Returns a mutable reverse iterator to the element following the last element of the reversed buffer.">rend()</a>. </p>

</div>
</div>
<a id="a477c8cd1839d955e4cf1795b0f3f77f5" name="a477c8cd1839d955e4cf1795b0f3f77f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477c8cd1839d955e4cf1795b0f3f77f5">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reverse_iterator <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reverse iterator to the first element of the reversed buffer. </p>
<p >It corresponds to the last element of the non-reversed buffer. If the buffer is empty, the returned iterator is equal to <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a1a2c780d821edaf9e0c28f10d85ef3df" title="Returns a mutable reverse iterator to the element following the last element of the reversed buffer.">rend()</a>. </p>

</div>
</div>
<a id="a9673040e5901313c464da3f57f2d9c67" name="a9673040e5901313c464da3f57f2d9c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9673040e5901313c464da3f57f2d9c67">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reverse_iterator <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element following the last element of the reversed buffer. </p>
<p >It corresponds to the element preceding the first element of the non-reversed buffer. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a1a2c780d821edaf9e0c28f10d85ef3df" name="a1a2c780d821edaf9e0c28f10d85ef3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2c780d821edaf9e0c28f10d85ef3df">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reverse_iterator <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reverse iterator to the element following the last element of the reversed buffer. </p>
<p >It corresponds to the element preceding the first element of the non-reversed buffer. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="af0d8702ace99b0900b69767a97da4ce8" name="af0d8702ace99b0900b69767a97da4ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d8702ace99b0900b69767a97da4ce8">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the buffer to a value that's greater or equal to new_cap. </p>
<p >If new_cap is greater than the current <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, new storage is allocated, otherwise the method does nothing. <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#af0d8702ace99b0900b69767a97da4ce8" title="Increase the capacity of the buffer to a value that&#39;s greater or equal to new_cap.">reserve()</a> does not change the size of the buffer. If new_cap is greater than <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>New capacity of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to this overload always preserve the value of <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a>; that is the extra capacity is always added on the end of the buffer. </dd>
<dd>
See reserve_front() and reserve(size_type, size_type) for alternatives. </dd></dl>

</div>
</div>
<a id="a623cd26be0deb9f68676776a97a1ace7" name="a623cd26be0deb9f68676776a97a1ace7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623cd26be0deb9f68676776a97a1ace7">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<p >If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of MoveInsertable and DefaultInsertable in order to use overload. If an exception is thrown, this function has no effect (strong exception guarantee). </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the throwing move constructor will be used. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

</div>
</div>
<a id="a07f3d9785851ff0b16a46e6e44eea286" name="a07f3d9785851ff0b16a46e6e44eea286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f3d9785851ff0b16a46e6e44eea286">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<p >If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of 'value' are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize the new elements with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of MoveInsertable and DefaultInsertable in order to use overload. </dd>
<dd>
If an exception is thrown, this function has no effect (strong exception guarantee). </dd></dl>

</div>
</div>
<a id="a5b7b67e8ecb8953737473d0d0e6e70ef" name="a5b7b67e8ecb8953737473d0d0e6e70ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7b67e8ecb8953737473d0d0e6e70ef">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<p >If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional default-inserted elements are prepended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of MoveInsertable and DefaultInsertable in order to use overload. If an exception is thrown, this function has no effect (strong exception guarantee). </dd>
<dd>
If T's move constructor is not noexcept and T is not CopyInsertable into *this, the throwing move constructor will be used. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

</div>
</div>
<a id="a6216822c8742678e03577149f1dd8dac" name="a6216822c8742678e03577149f1dd8dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6216822c8742678e03577149f1dd8dac">&#9670;&nbsp;</a></span>resize_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::resize_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<p >If the current size is greater than count, the container is reduced to its last count elements. If the current size is less than count, additional copies of 'value' are prepended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize the new elements with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>T must meet the requirements of MoveInsertable and DefaultInsertable in order to use overload. </dd>
<dd>
If an exception is thrown, this function has no effect (strong exception guarantee). </dd></dl>

</div>
</div>
<a id="a7b622b7abb5c7a99943cc0709de5019e" name="a7b622b7abb5c7a99943cc0709de5019e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b622b7abb5c7a99943cc0709de5019e">&#9670;&nbsp;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::shift_left </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the underlying storage such that the starting index of the buffer is shifted left by 'count', without changing the order of the elements in the buffer. </p>
<p >Example: Underlying storage before shifting: [-, -, -, a, b, c, d, -, -] ^ <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> == 3 Underlying storage after shifting left by 2: [-, a, b, c, d, -, -, -, -] ^ <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> == 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements to shift the buffer left by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If T is MoveInsertible and std::is_nothrow_move_constructible_v&lt;T&gt; is true, and std::is_nothrow_move_assignable_v&lt;T&gt; is true, this function throws only those exceptions thrown when move-constructing objects of type T using std::allocator_traits&lt;Allocator&gt;::construct(). Otherwise if T is MoveInsertible and CopyInsertible but has a throwing move constructor or move assignment operator, elements are shifted using copy construction and copy assignment. In both of the above two cases, the strong exception guarantee is maintained. Otherwise, if T is not CopyInsertible, the strong exception gaurantee is waived; elements are shifted using move construction and move assignment, but if an exception is thrown, the buffer will be left in a valid but unspecified state. </dd>
<dd>
This function does not allocate, all data movement is done in-place. </dd>
<dd>
This function makes O(this-&gt;<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>) calls to T's move/copy constructor and assignment operator. </dd></dl>

</div>
</div>
<a id="ae5fd24b0fe7df00f7a3aba6b77bfe30c" name="ae5fd24b0fe7df00f7a3aba6b77bfe30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fd24b0fe7df00f7a3aba6b77bfe30c">&#9670;&nbsp;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::shift_right </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the underlying storage such that the starting index of the buffer is shifted right by 'count', without changing the order of the elements in the buffer. </p>
<p >Example: Underlying storage before shifting: [-, a, b, c, d, -, -, -, -] ^ <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> == 1 Underlying storage after shifting right by 2: [-, -, -, a, b, c, d, -, -] ^ <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a13463b6672db6727101be4931c605e36" title="Returns the index into the raw (physical) memory buffer of the first element (the physical index of l...">begin_index()</a> == 3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements to shift the buffer right by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If T is MoveInsertible and std::is_nothrow_move_constructible_v&lt;T&gt; is true, and std::is_nothrow_move_assignable_v&lt;T&gt; is true, this function throws only those exceptions thrown when move-constructing objects of type T using std::allocator_traits&lt;Allocator&gt;::construct(). Otherwise if T is MoveInsertible and CopyInsertible but has a throwing move constructor or move assignment operator, elements are shifted using copy construction and copy assignment. In both of the above two cases, the strong exception guarantee is maintained. Otherwise, if T is not CopyInsertible, the strong exception gaurantee is waived; elements are shifted using move construction and move assignment, but if an exception is thrown, the buffer will be left in a valid but unspecified state. </dd>
<dd>
This function does not allocate, all data movement is done in-place. </dd>
<dd>
This function makes O(this-&gt;<a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>) calls to T's move/copy constructor and assignment operator. </dd></dl>

</div>
</div>
<a id="a57a645554b9caa2f8ab91bf41c51d578" name="a57a645554b9caa2f8ab91bf41c51d578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a645554b9caa2f8ab91bf41c51d578">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<p >It is a non-binding request to reduce <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a870c2775e2ca7f70ac254637595b7c32" title="Returns the number of elements that the container has currently allocated space for.">capacity()</a> to <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a47a8d4b9a0f71bc872bbf9b2453f2324" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>. It depends on the implementation whether the request is fulfilled. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</p>
<dl class="section note"><dt>Note</dt><dd>If an exception is thrown other than by T's move constructor, there are no effects. </dd></dl>

</div>
</div>
<a id="a6b3dc4f2240d1567f88489329a230e40" name="a6b3dc4f2240d1567f88489329a230e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3dc4f2240d1567f88489329a230e40">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">tim::circular_buffer::CircularBuffer</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. </p>
<p >Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The container to exchange the contents with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value is true, then the allocators are exchanged using an unqualified call to non-member swap. Otherwise, they are not swapped (and if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4d0297f2d8c63b22aadf06e537b92b40" title="Returns the allocator associated with the container.">get_allocator()</a> != other.get_allocator(), the behavior is undefined). </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a55b6b7343999e91035028b09e5db5b61" name="a55b6b7343999e91035028b09e5db5b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b6b7343999e91035028b09e5db5b61">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr friend bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are not equal, that is, they have a different number of elements or if any element in lhs compares not equal with the element in rhs at the same position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The first container whose contents will be compared. </td></tr>
    <tr><td class="paramname">r</td><td>The second container whose contents will be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the contents of the buffers are equal, true otherwise </dd></dl>

</div>
</div>
<a id="a864f698605dcb25a6ff4ee76536c74bc" name="a864f698605dcb25a6ff4ee76536c74bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864f698605dcb25a6ff4ee76536c74bc">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr friend bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The first container whose contents will be compared. </td></tr>
    <tr><td class="paramname">r</td><td>The second container whose contents will be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of the buffers are equal, false otherwise </dd></dl>

</div>
</div>
<a id="ae75cd5c74b3fa490a26b24da745cd7ff" name="ae75cd5c74b3fa490a26b24da745cd7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75cd5c74b3fa490a26b24da745cd7ff">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr friend void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html">CircularBuffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of 'l' with those of 'r'. </p>
<p >Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The first container whose contents will be exchanged. </td></tr>
    <tr><td class="paramname">r</td><td>The second container whose contents will be exchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value is true, then the allocators are exchanged using an unqualified call to non-member swap. Otherwise, they are not swapped (and if <a class="el" href="structtim_1_1circular__buffer_1_1_circular_buffer.html#a4d0297f2d8c63b22aadf06e537b92b40" title="Returns the allocator associated with the container.">get_allocator()</a> != other.get_allocator(), the behavior is undefined). </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/vansl/source/repos/circular-buffer-cpp/include/tim/circular-buffer/<a class="el" href="_circular_buffer_8hpp_source.html">CircularBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
